# yapf: disable
# isort: skip_file

# Standard imports.
import asyncio
import grpc
import json
import sys
import traceback
import uuid
import resemble.aio.state_managers
from abc import abstractmethod
from datetime import datetime, timedelta
from google.protobuf.descriptor import FileDescriptor
from google.protobuf.json_format import MessageToJson, Parse, ParseDict
from google.protobuf.message import Message
from google.rpc import status_pb2
from grpc_status import rpc_status
from resemble.aio.contexts import (
    Context,
    ReaderContext,
    TransactionContext,
    WriterContext,
)
from resemble.aio.errors import Aborted, Error, _from_status
from resemble.aio.headers import Headers
from resemble.aio.idempotency import IdempotencyManager, Idempotency
from resemble.aio.internals.channel_manager import _ChannelManager
from resemble.aio.internals.middleware import Middleware
from resemble.aio.internals.tasks_cache import TasksCache
from resemble.aio.internals.tasks_dispatcher import TasksDispatcher
from resemble.aio.headers import Headers
from resemble.aio.servicers import Servicer, Serviceable
from resemble.aio.state_managers import Effects, StateManager
from resemble.aio.stubs import Stub
from resemble.aio.tasks import TaskEffect
from resemble.aio.types import ActorId, assert_type, GrpcMetadata, ServiceName
from resemble.aio.workflows import Workflow
from typing import (
    AsyncIterable,
    AsyncIterator,
    Awaitable,
    Callable,
    Optional,
    TypeAlias,
    Union,
)

# User defined or referenced imports.
import google.protobuf.empty_pb2
import google.protobuf.struct_pb2
import resemble.v1alpha1.inspect.inspect_pb2
import resemble.v1alpha1.inspect.inspect_pb2_grpc
import resemble.v1alpha1.options_pb2
# Additionally re-export all messages from the pb2 module.
from resemble.v1alpha1.inspect.inspect_pb2 import (
    GetAllActorsRequest,
    GetAllActorsResponse,
    InspectState,
)


def MakeLegacyGrpcServiceable(
    # A legacy gRPC servicer type can't be more specific than `type`,
    # because legacy gRPC servicers (as generated by the gRPC `protoc`
    # plugin) do not share any common base class other than `object`.
    servicer_type: type
) -> Serviceable:
    raise ValueError(f"Unknown legacy gRPC servicer type '{servicer_type}'")


class InspectServicerMiddleware(Middleware):

    def __init__(
        self,
        servicer: 'InspectServicer',
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
    ):
        super().__init__(
            channel_manager=channel_manager,
            service_name='resemble.v1alpha1.inspect.Inspect',
        )

        self._servicer = servicer
        self._state_manager = state_manager
        self.tasks_dispatcher = TasksDispatcher(self.dispatch, tasks_cache)

        # Store the type of each method's request so that stored requests can be
        # deserialized into the correct type.
        self.request_type_by_method_name: dict[str, type[Message]] = {
            'Create': google.protobuf.empty_pb2.Empty,
            'GetAllActors': resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        }

    def add_to_server(self, server: grpc.aio.Server) -> None:
        resemble.v1alpha1.inspect.inspect_pb2_grpc.add_InspectServicer_to_server(
            self, server
        )

    async def inspect(self, actor_id: ActorId) -> AsyncIterator[Message]:
        """Implementation of `Middleware.inspect()`."""
        context = self.create_context(
            headers=Headers(
                service_name='resemble.v1alpha1.inspect.Inspect',
                actor_id=actor_id,
            ),
            context_type=ReaderContext,
        )

        async with self._state_manager.streaming_reader_idempotency_key(
            context, self._servicer.__state_type__
        ) as states:
            async for (state, idempotency_key) in states:
                yield state

    async def react_query(
        self,
        grpc_context: grpc.aio.ServicerContext,
        actor_id: ActorId,
        method: str,
        request_bytes: bytes,
    ) -> AsyncIterator[Message]:
        """Returns the response of calling 'method' given a message
        deserialized from the provided 'request_bytes' for each state
        update that creates a different response.

        NOTE: only unary reader methods are supported."""
        # Need to define these up here since we can only do that once.
        last_response: Optional[Message] = None
        aggregated_idempotency_keys: list[uuid.UUID] = []
        if 'Create' == method:
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            raise ValueError(f"Method '{method}' is invalid")
            yield  # Necessary for type checking.
        elif 'GetAllActors' == method:
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            raise ValueError(f"Method '{method}' is invalid")
            yield  # Necessary for type checking.
        else:
            raise RuntimeError(f"Method '{method}' not found")
            yield  # Necessary for type checking.

    async def react_mutate(
        self,
        actor_id: ActorId,
        method: str,
        request_bytes: bytes,
        idempotency_key: str,
    ) -> Message:
        """Returns the response of calling 'method' given a message
        deserialized from the provided 'request_bytes'."""
        if 'Create' == method:
            request = google.protobuf.empty_pb2.Empty()
            request.ParseFromString(request_bytes)
            return await self._Create(
                request,
                self.create_context(
                    headers=Headers(
                        service_name='resemble.v1alpha1.inspect.Inspect',
                        actor_id=actor_id,
                        idempotency_key=uuid.UUID(idempotency_key),
                    ),
                    context_type=WriterContext,
                )
            )
        elif 'GetAllActors' == method:
            # Invariant here is that users should not have called this
            # directly but only through code generated React
            # components which should not have been generated except
            # for valid method candidates.
            raise ValueError(f"Method '{method}' is invalid")
        else:
            raise RuntimeError(f"Method '{method}' not found")

    async def dispatch(
        self, task: TaskEffect, *, only_validate: bool = False
    ) -> Message:
        """Dispatches the tasks to execute unless 'only_validate' is set to
        true, in which case just ensures that the task actually exists.
        Note that this function will be called *by* tasks_dispatcher; it will
        not itself call into tasks_dispatcher."""
        # Need to forward declare context since we set it to different
        # types depending on if the task is a reader or a writer.
        context: Context


        # There are no tasks for this service.
        start_or_validate = "start" if not only_validate else "validate"
        raise RuntimeError(
            f"Attempted to {start_or_validate} task '{task.method_name}' "
            f"on 'Inspect' which does not exist"
        )

    # Inspect specific methods:
    async def _Create(
        self,
        request: google.protobuf.empty_pb2.Empty,
        context: WriterContext,
    ) -> google.protobuf.empty_pb2.Empty:
        # Check if we already have performed this mutation!
        #
        # We do this _before_ calling 'transactionally()' because
        # if this call is for a transaction method _and_ we've
        # already performed the transaction then we don't want to
        # become a transaction participant (again) we just want to
        # return the transaction's response.
        response_bytes: Optional[bytes] = (
            self._state_manager.get_response_if_idempotent_mutation(
                context
            )
        )

        if response_bytes is not None:
            response = google.protobuf.empty_pb2.Empty()
            response.ParseFromString(response_bytes)
            return response

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )

            # TODO: this loads a `state` object even when we know we're calling a constructor,
            # in which case (by definition) there is no state. Can we (and is it worth
            # the effort to) change this call to avoid that overhead in that case?
            async with self._state_manager.writer(
                context,
                self._servicer.__state_type__,
                transaction=transaction,
                from_constructor=False,
                requires_constructor=False
            ) as (state, writer):
                effects = await self._servicer.Create(
                    context,
                    state,
                    request
                )

                if effects.tasks is not None:
                    # NOTE: we validate tasks added as part of a
                    # transaction when we prepare.
                    if transaction is None:
                        await self.tasks_dispatcher.validate(
                            effects.tasks
                        )

                await writer.complete(effects)

                if effects.tasks is not None:
                    if transaction is None:
                        self.tasks_dispatcher.dispatch(effects.tasks)
                    else:
                        assert all(
                            task.task_id.service == transaction.service
                            for task in effects.tasks
                        ), 'Task service does not match transaction service'
                        transaction.tasks.extend(effects.tasks)

                return effects.response

    async def Create(
        self,
        request: google.protobuf.empty_pb2.Empty,
        grpc_context: grpc.aio.ServicerContext,
    ) -> google.protobuf.empty_pb2.Empty:
        try:
            context: Optional[WriterContext] = None
            context = self.create_context_from_grpc(
                grpc_context=grpc_context, context_type=WriterContext
            )

            assert context is not None

            return await self._Create(
                request,
                context,
            )
        except Aborted as aborted:
            await self._abort_with_status(
                grpc_context,
                aborted,
            )
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            traceback.print_exc()

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                #
                # NOTE: we'll want to propagate participants if we're
                # in a transaction method once we support nested
                # transactions, but for now we only need to propagate
                # participants when we're not in a transaction method.
                if not isinstance(context, TransactionContext):
                    grpc_context.set_trailing_metadata(
                        grpc_context.trailing_metadata() +
                        context.participants.to_grpc_metadata()
                    )

    async def _GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        context: ReaderContext,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:

        async with self._state_manager.transactionally(
            context, self.tasks_dispatcher
        ) as transaction:
            if transaction is not None:
                context.participants.add(
                    self._servicer.__service_name__, context.actor_id
                )

            async with self._state_manager.streaming_reader(
                context, self._servicer.__state_type__
            ) as states:
                async for response in self._servicer.GetAllActors(
                    context,
                    states,
                    request
                ):
                    if transaction is not None:
                        # We need the transaction to be stored
                        # _before_ yielding the first response to
                        # the user otherwise they may read two
                        # different states if we crash.
                        await self._state_manager.transaction_participant_store(
                            transaction
                        )
                    yield response

    async def GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        grpc_context: grpc.aio.ServicerContext,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        try:
            context: Optional[ReaderContext] = None
            context = self.create_context_from_grpc(
                grpc_context=grpc_context, context_type=ReaderContext
            )

            assert context is not None

            async for response in self._GetAllActors(
                request,
                context,
            ):
                yield response
        except Aborted as aborted:
            await self._abort_with_status(
                grpc_context,
                aborted,
            )
        except asyncio.CancelledError:
            # It's pretty normal for an RPC to be cancelled; it's not useful to
            # print a stack trace.
            raise
        except:
            # Print the exception stack trace for easier debugging. Note
            # that we don't include the stack trace in an error message
            # for the same reason that gRPC doesn't do so by default,
            # see https://github.com/grpc/grpc/issues/14897, but since this
            # should only get logged on the server side it is safe.
            traceback.print_exc()

            # Re-raise the exception for gRPC to handle!
            raise
        finally:
            if context is not None and context.transaction_id is not None:
                # Propagate transaction participants.
                #
                # NOTE: we'll want to propagate participants if we're
                # in a transaction method once we support nested
                # transactions, but for now we only need to propagate
                # participants when we're not in a transaction method.
                if not isinstance(context, TransactionContext):
                    grpc_context.set_trailing_metadata(
                        grpc_context.trailing_metadata() +
                        context.participants.to_grpc_metadata()
                    )


    async def _abort_with_status(
        self,
        grpc_context: grpc.aio.ServicerContext,
        aborted: Aborted,
        error_type: Optional[type] = None,
    ):
        await grpc_context.abort_with_status(
            rpc_status.to_status(aborted.to_status(error_type))
        )


class _InspectStub(Stub):

    def __init__(
        self,
        context_or_workflow: Context | Workflow,
        actor_id: ActorId,
    ):
        super().__init__(
            channel_manager=context_or_workflow.channel_manager,
            idempotency_manager=context_or_workflow,
            service_name='resemble.v1alpha1.inspect.Inspect',
            actor_id=actor_id,
            context=(
                context_or_workflow
                if issubclass(type(context_or_workflow), Context)
                else None # type: ignore
            ),
        )

        channel = self._channel_manager.get_channel_for(
            InspectServicer, actor_id
        )
        self._stub = resemble.v1alpha1.inspect.inspect_pb2_grpc.InspectStub(channel)


class InspectReaderStub(_InspectStub):

    def __init__(
        self,
        context_or_workflow: ReaderContext | WriterContext | TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(
            context_or_workflow,
            [ReaderContext, WriterContext, TransactionContext, Workflow]
        )
        super().__init__(context_or_workflow, actor_id)

    # Inspect specific methods:

    async def GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        async with self._call(
            'GetAllActors',
            self._stub.GetAllActors,
            request,
            unary=False,
            reader=True,
            response_type=resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse,
            metadata=metadata,
        ) as call:
            assert isinstance(call, AsyncIterable)
            async for response in call:
                yield response


class InspectWriterStub(_InspectStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(context_or_workflow, [TransactionContext, Workflow])
        super().__init__(context_or_workflow, actor_id)

    # Inspect specific methods:
    async def Create(
        self,
        request: google.protobuf.empty_pb2.Empty,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> google.protobuf.empty_pb2.Empty:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=google.protobuf.empty_pb2.Empty,
                metadata=metadata,
                idempotency_key=idempotency_key,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        async with self._call(
            'GetAllActors',
            self._stub.GetAllActors,
            request,
            unary=False,
            reader=True,
            response_type=resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse,
            metadata=metadata,
        ) as call:
            assert isinstance(call, AsyncIterable)
            async for response in call:
                yield response


class InspectTransactionStub(_InspectStub):

    def __init__(
        self,
        context_or_workflow: TransactionContext | Workflow,
        actor_id: ActorId
    ):
        assert_type(context_or_workflow, [TransactionContext, Workflow])
        super().__init__(context_or_workflow, actor_id)

    # Inspect specific methods:
    async def Create(
        self,
        request: google.protobuf.empty_pb2.Empty,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> google.protobuf.empty_pb2.Empty:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=google.protobuf.empty_pb2.Empty,
                metadata=metadata,
                idempotency_key=idempotency_key,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        async with self._call(
            'GetAllActors',
            self._stub.GetAllActors,
            request,
            unary=False,
            reader=True,
            response_type=resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse,
            metadata=metadata,
        ) as call:
            assert isinstance(call, AsyncIterable)
            async for response in call:
                yield response


class InspectWorkflowStub(_InspectStub):

    def __init__(
        self,
        workflow: Workflow,
        actor_id: ActorId
    ):
        assert_type(workflow, [Workflow])
        super().__init__(workflow, actor_id)

    # Inspect specific methods:
    async def Create(
        self,
        request: google.protobuf.empty_pb2.Empty,
        idempotency: Optional[Idempotency] = None,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> google.protobuf.empty_pb2.Empty:
        idempotency_key: Optional[str]
        with self._idempotency_manager.idempotently(
            service=self._headers.service_name,
            actor_id=self._headers.actor_id,
            method='Create',
            request=request,
            metadata=metadata,
            idempotency=idempotency,
        ) as idempotency_key:
            async with self._call(
                'Create',
                self._stub.Create,
                request,
                unary=True,
                reader=False,
                response_type=google.protobuf.empty_pb2.Empty,
                metadata=metadata,
                idempotency_key=idempotency_key,
            ) as call:
                assert isinstance(call, Awaitable)
                return await call

    async def GetAllActors(
        self,
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
        *,
        metadata: Optional[GrpcMetadata] = None,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        async with self._call(
            'GetAllActors',
            self._stub.GetAllActors,
            request,
            unary=False,
            reader=True,
            response_type=resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse,
            metadata=metadata,
        ) as call:
            assert isinstance(call, AsyncIterable)
            async for response in call:
                yield response


class InspectTasksStub(_InspectStub):

    def __init__(self, context: WriterContext, actor_id: ActorId):
        assert_type(context, [WriterContext])
        super().__init__(context, actor_id)

    # Inspect specific methods:



class InspectServicer(Servicer):
    __service_name__ = 'resemble.v1alpha1.inspect.Inspect'
    __file_descriptor__ = resemble.v1alpha1.inspect.inspect_pb2.DESCRIPTOR
    __state_type__: type[Message] = resemble.v1alpha1.inspect.inspect_pb2.InspectState

    def __init__(self):
        # NOTE: need to hold on to the middleware so we can do inline
        # writes (see 'self.write(...)').
        #
        # Because '_middleware' is not really private this does mean
        # users may do possibly dangerous things, but this is no more
        # likely given they could have already overridden
        # 'create_middleware()'.
        self._middleware: Optional[InspectServicerMiddleware] = None

    def create_middleware(
        self,
        state_manager: StateManager,
        channel_manager: _ChannelManager,
        tasks_cache: TasksCache,
    ) -> InspectServicerMiddleware:
        self._middleware = InspectServicerMiddleware(
            self, state_manager, channel_manager, tasks_cache
        )
        return self._middleware

    class Tasks:
        def __init__(self, when: Optional[datetime | timedelta] = None):
            self._when = when

        # Inspect specific methods:

    def schedule(
        self,
        when: Optional[datetime | timedelta] = None,
    ):
        return self.Tasks(when)

    class Effects(resemble.aio.state_managers.Effects):
        def __init__(
            self,
            *,
            state: resemble.v1alpha1.inspect.inspect_pb2.InspectState,
            response: Optional[Message] = None,
            tasks: Optional[list[TaskEffect]] = None
        ):
            assert_type(state, [resemble.v1alpha1.inspect.inspect_pb2.InspectState])

            super().__init__(state=state, response=response, tasks=tasks)

    class CreateEffects(Effects):
        def __init__(
            self,
            *,
            state: resemble.v1alpha1.inspect.inspect_pb2.InspectState,
            response: google.protobuf.empty_pb2.Empty,
            tasks: Optional[list[TaskEffect]] = None
        ):
            assert_type(state, [resemble.v1alpha1.inspect.inspect_pb2.InspectState])
            assert_type(response, [google.protobuf.empty_pb2.Empty])

            super().__init__(state=state, response=response, tasks=tasks)




    async def read(
        self, context: TransactionContext
    ) -> resemble.v1alpha1.inspect.inspect_pb2.InspectState:
        """Read the current state within a transaction."""
        assert_type(context, [TransactionContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        return await self._middleware._state_manager.read(
            context, self.__state_type__
        )

    async def write(
        self,
        context: TransactionContext,
        f: Callable[[WriterContext, Message], Awaitable[Effects]],
    ):
        """Perform an "inline write" within a transaction."""
        assert_type(context, [TransactionContext])

        if self._middleware is None:
            raise RuntimeError(
                'Resemble middleware was not created; '
                'are you using this class without Resemble?'
            )

        writer_context: WriterContext = self._middleware.create_context(
            headers=Headers(
                service_name=self.__service_name__,
                actor_id=context.actor_id,
                transaction_id=context.transaction_id,
                transaction_coordinator_service=context
                .transaction_coordinator_service,
                transaction_coordinator_actor_id=context
                .transaction_coordinator_actor_id
            ),
            context_type=WriterContext,
        )

        async with self._middleware._state_manager.transactionally(
            writer_context, self._middleware.tasks_dispatcher
        ) as transaction:
            assert transaction is not None
            async with self._middleware._state_manager.writer(
                writer_context, self.__state_type__, transaction=transaction
            ) as (state, writer):
                effects: InspectServicer.Effects = await f(
                    writer_context, state
                )

                assert_type(effects, [InspectServicer.Effects])

                # NOTE: we validate tasks added as part of a
                # transaction when we prepare.

                await writer.complete(effects)

                if effects.tasks is not None:
                    assert all(
                        task.task_id.service == transaction.service
                        for task in effects.tasks
                    ), 'Task service does not match transaction service'
                    transaction.tasks.extend(effects.tasks)

                return effects.response  # May be 'None'.

    # Inspect specific methods:
    @abstractmethod
    async def Create(
        self,
        context: WriterContext,
        state: resemble.v1alpha1.inspect.inspect_pb2.InspectState,
        request: google.protobuf.empty_pb2.Empty,
    ) -> CreateEffects:
        raise NotImplementedError

    @abstractmethod
    async def GetAllActors(
        self,
        context: ReaderContext,
        states: AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.InspectState],
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        raise NotImplementedError
        yield  # Necessary for type checking.


class Inspect:

    Interface: TypeAlias = InspectServicer

    Effects: TypeAlias = InspectServicer.Effects

    CreateEffects: TypeAlias = Interface.CreateEffects



    def __init__(self, id: str):
        self._id = id
        self._reader_stub: Optional[InspectReaderStub] = None
        self._writer_stub: Optional[InspectWriterStub] = None
        self._workflow_stub: Optional[InspectWorkflowStub] = None

    def reader(
        self,
        context: ReaderContext | WriterContext | TransactionContext | Workflow,
    ) -> InspectReaderStub:
        if self._reader_stub is None:
            self._reader_stub = InspectReaderStub(
                context, self._id
            )
        assert self._reader_stub is not None
        assert self._reader_stub._idempotency_manager == context
        return self._reader_stub

    def writer(
        self,
        context: TransactionContext | Workflow,
    ) -> InspectWriterStub:
        if self._writer_stub is None:
            self._writer_stub = InspectWriterStub(
                context, self._id
            )
        assert self._writer_stub is not None
        assert self._writer_stub._idempotency_manager == context
        return self._writer_stub

    def workflow(
        self,
        workflow: Workflow,
    ) -> InspectWorkflowStub:
        if self._workflow_stub is None:
            self._workflow_stub = InspectWorkflowStub(
                workflow, self._id
            )
        assert self._workflow_stub is not None
        assert self._workflow_stub._idempotency_manager == workflow
        return self._workflow_stub

    # Inspect specific methods:
    async def Create(
        self,
        rsm_context_or_workflow: TransactionContext | Workflow,
        rsm_idempotency: Optional[Idempotency] = None,
        rsm_metadata: Optional[GrpcMetadata] = None,
    ) -> google.protobuf.empty_pb2.Empty:
        request = google.protobuf.empty_pb2.Empty(
        )
        return await self.writer(rsm_context_or_workflow).Create(
            request,
            rsm_idempotency,
            metadata=rsm_metadata,
        )

    async def GetAllActors(
        self,
        context: ReaderContext | WriterContext | TransactionContext | Workflow,
        rsm_metadata: Optional[GrpcMetadata] = None,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        request = resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest(
        )
        call = self.reader(context).GetAllActors(
            request,
            metadata=rsm_metadata,
        )
        async for response in call:
            yield response


class InspectServicerNodeAdaptor(Inspect.Interface):

    def __init__(self):
        self._js_servicer_reference = self._construct_js_servicer()

    # Inspect specific methods:
    async def Create(
        self,
        context: WriterContext,
        state: resemble.v1alpha1.inspect.inspect_pb2.InspectState,
        request: google.protobuf.empty_pb2.Empty,
    ) -> Inspect.CreateEffects:
        json_state = MessageToJson(state)

        json_request = MessageToJson(request)

        json_effects = await self._writer(
            self._js_servicer_reference,
            'Create',
            context,
            json_state,
            json_request,
        )

        effects = json.loads(json_effects)

        assert not hasattr(effects, 'tasks'), "JS tasks not yet implemented"

        return Inspect.CreateEffects(
            state=ParseDict(
                effects['state'],
                resemble.v1alpha1.inspect.inspect_pb2.InspectState(),
            ),
            response=ParseDict(
                effects['response'],
                google.protobuf.empty_pb2.Empty(),
            ),
        )

    async def GetAllActors(
        self,
        context: ReaderContext,
        states: AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.InspectState],
        request: resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsRequest,
    ) -> AsyncIterable[resemble.v1alpha1.inspect.inspect_pb2.GetAllActorsResponse]:
        raise NotImplementedError
        yield  # Necessary for type checking.



class InspectNodeAdaptor(Inspect):

    async def _reader(
        self,
        method: str,
        context: ReaderContext | WriterContext | TransactionContext | Workflow,
        request_type: type[Message],
        json_request: str,
    ) -> str:
        request = request_type()

        Parse(json_request, request)

        response = await getattr(super().reader(context), method)(request)

        return MessageToJson(response)

    async def _writer(
        self,
        method: str,
        context: TransactionContext | Workflow,
        request_type: type[Message],
        json_request: str,
    ) -> str:
        request = request_type()

        Parse(json_request, request)

        response = await getattr(super().writer(context), method)(request)

        return MessageToJson(response)

# yapf: enable
