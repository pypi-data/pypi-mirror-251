# Почему аннотация list[str] - раковая опухоль вашего Python кода?

Небольшая ремарка - все описанное в данной статье применимо не только к **Python** коду, но и к коду вообще (в т.ч. и на языках с явной/строгой типизацией). Но так сложилось, что большую часть времени я - Python разработчик, поэтому речь будем вести о нем.

Так в чем, собственно, проблема?

Проблема в том, что многие начинающие разработчики типизируют функции по принципу **WYSIATI** ("что я вижу - то и есть"). Если они пишут функцию, которая используется с `list[str]` - то и в типе аргумента они поставят `list[str]`. Затем эти начинающие разработчики вырастают, но однажды закрепленный навык так и остается с ними (зачем анализировать то, что работает) до того момента, пока не станет БОЛЬНО. Причем инерция мышления не позволяет нам вовремя понять, что эта БОЛЬ находится в самом корне того, как мы типизируем наш код.

В рамках статьи я хотел бы поделиться своими размышления и наблюдениями на этот счет, которые, надеюсь, помогут вам избежать типичных ошибок.

## Как мы пишем код

UPD: я знаю, что существуют сверхлюди, у которых все всегда сразу получается идеально. Но, к сожалению, опыт говорит мне о том, что таких людей мало.

Так или иначе, большинство из нас пишет код СВЕРХУ ВНИЗ. Начиная от более высокого уровня абстракции к более низкому. Мы получаем требования от бизнеса, формулируем задачу, декомпозируем, декомпозируем, ...., пишем код.

В крайких случаях это выливается в то, что мы пишем простыню, выполняющую задачу, разрезаем ее на отдельные функции/классы и продолжаем это процесс до момента, когда не будем удовлетворены структурой. И весь ворох прочитанных книг по чистой архитектуре не позволят вам полностью сломать мозг и всегда проектировать систему СНИЗУ ВВЕРХ.

В итоге, когда мы только пишем новую функцию, мы уже видим место, где она будет использоваться. И нам очень тяжело астрагироваться от этого контекста. И именно это приводит нас к тому, что мы можем совершить (и часто совершаем) когнитивную ошибку и типизируем функции в соответсвии с тем, что мы в них собираемся передавать. Мы это делаем не потому, что мы какие-то глупые и не можем делать правильно, а потому что мозг ленивый и **WYSIATI** - "функция принимает list, значит так и напишем".

## Стреляем себе в ноги

Почему это плохо? Работает же!

И ведь действительно работает, но в ограниченном контексте. Пока ваша функция/класс используется в 1-3 местах в проекте, все нормально. Но по мере роста проекта эти проблемы могут всплыть на поверхность. А могут и не всплыть... В этом и заключается основная проблема, почему мы так долго цепляемся за старую привычку.

Наша функция - это инкапсулированный кусок логики, который предоставляет внешнему миру информацию о себе через свою сигнатуру. И тут существует сразу несколько проблем.

1. Определяя сигнатуру функции исходя из контеста ее использования, а не внутренней логики, мы обманываем мир и предоставляем ему информацию О КОНТЕКСТЕ ИСПОЛЬЗОВАНИЯ, а не о самой функции.

2. С другой стороны, входящая сигнатура функции накладывает ограничения на внешний код (на тип передаваемых объектов). Слишком строгие ограничения абсолютно бессмысленны: они затрудняют написание внешнего кода (а значит, всего проекта в совокупности), а также препятствуют "местечковым оптимизациям".

К сожалению, эти проблемы имют накопительный эффект и, по мере роста числа криво аннотированных функций в проекте, нам становится все труднее и труднее работать. Мы все больше и больше времени тратим на подгонку нашего кода под требования вызываемых функций, стыковку их друг с другом, а также исправление ошибок mypy (а если их много - то вообще на них плюем, что может вылиться в катастрофу).

## Примеры

Допустим, у нас есть скрипт, который читает текст из файла и считает количество слов в нем (пример утрирован).

```python
from pathlib import Path

def get_size(data: list[str]) -> int:
    return len(data)

def get_file_content(file: Path) -> str:
	return file.read_text()

if __name__ == "__main__":
	current_dir = Path(__file__).resolve().parent
	text = get_file_content(current_dir / "text.txt")
	size = get_size(text.split())
	print(size)
```

И вроде бы аннотации расставлены верно и непротиворечиво, и mypy не ругается, и тесты проходят, да и принципу единственной ответственности соответсвует. Но что-то все равно не так.

Давайте взглянем на функцию `get_size`.

```python
def get_size(data: list[str]) -> int:
    return len(data)
```

Кажется, в отрыве от всего приложения (как она и должна рассматриваться), она делает что-то странное: зачем нам передавать именно `list[str]` для того, чтобы взять от него длину? Мы не можем передать `list[Any]` или вообще `tuple[Any, ...]`? Конечно можем!

Конечно, правильная аннотация в данном случае:

```python
from typing import Sized

def get_size(data: Sized) -> int:
    ...
```

Здесь промах очевиден, однако в других случаях это не так. Например тут:

```python
def print_list(data: list[str]) -> None:
    for i in data:
	    print(i)
```

Допустим, вы решили немного абстрагироваться и сделали следующее:

```python
from typing import Any, Sequence

def print_sequence(data: Sequence[Any]) -> None:
	...
```

Уже лучше, но тоже не отражает реальность. Например, вызов этой функции с **Set** `print_sequence({1, 2, 3})` приведет к ошибке mypy. Хотя код работает корректно!

Дело в том, что [Sequence](https://docs.python.org/3/library/collections.abc.html) - это протокол, который помимо метода `__iter__` требует еще множество других методов ([полный список для всех типов](https://docs.python.org/3/library/collections.abc.html)). Но по факту мы ведь используем только его.

Следовательно, корректная аннотация выглядит так:

```python
from typing import Any, Iterable

def print_iterable(data: Iterable[Any]) -> None:
    ...
```

Теперь наша функция готова принимать и генераторы, и **Set**'ы, а главное - любые кастомные классы, поддерживающие итерирование.

Кстати, в примере выше вы получили наглядную демонстрацию тезиса, почему вшивать тип переменных в название функции - плохая идея)

## Выводы

Пример с `list[str]` - это банальная абстракция о том, как мы вообще работаем с типами. На самом деле очень часто эти ошибки встречаются в аннотации атрибутов классов,  что заставляет нас бороться с mypy в наследниках, использовании пользовательских классов в качестве типов, да и вообще везде... Особенно критично это для OSS проектов, где публичный API должен принимать настолько широкий список типов, насколько возможно (однако и там я вижу пресловутые `list[str]`).

С другой стороны (что мы частично затронули в статье про [декораторы](https://habr.com/ru/articles/750312/)), излишне слабая типизация затирает информацию о реально используемых типах и несет не меньшие проблемы.

Эти проблемы актуальный для всех ЯП - со строгой/нестрогой, статической/динамической типизацией. Их корень банально кроется в том, как мы пишем код.

Да, настолько сильно задумываться над типами - это лишняя когнитивная нагрузка. А вот поставить `list[str]` требует пол-нейрона (**WYSIATI**). Однако, задумавшись над этим, вы переходите из режима кодогенерации (привет ChatGPT) в режим творческого написания кода, что поможет лучше спроектировать ваш кусок кода в принципе. Этакая когнитивная пощечина.

Не говоря уже о долгосрочной пользе, выраженном в сэкономленном на борьбе с ошибками типов времени.

В заключении могу рекомендовать одно мнемоническое правило

> сигнатура объекта должна предоставлять максимально точную информацию о его поведении

Что не очевидно, но

> *"максимально точно"* = максимально *абстрактно на входе* + максимально *конкретно на выходе*

Грамотное использование протоколов - залог успеха. Однако, если вы решите использовать собственные протоколы или типизировать асбтрактный классы для наследования, то там лучше все аннотации делать масимально абстрактными. Впрочем, вы разберетесь, я верю.

Надеюсь, эта небольшая статья поможет вам переосмыслить то, как вы делаете рутинные действия и улучшить качество производимого вами продукта.

### Дополнительные материалы

* книжка ["Типизированный Python"](https://to.digital/typed-python/) - как будто бы единственный систематизированный материал по типизации в Python на текущий момент (хотя и с существенными пробелами)
* [тренажер](https://python-type-challenges.zeabur.app/) - как leetcode, но для типов
