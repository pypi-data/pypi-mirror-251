[tool.poetry]
description = "Database models and migrations for the Local News Lab's article recommendation system"
name = "article-rec-db"
version = "0.0.11"
authors = ["Duy Nguyen <hello.duyknguyen@gmail.com>"]
license = "MIT"
readme = "README.md"
homepage = "https://github.com/LocalAtBrown/article-rec-db/"
repository = "https://github.com/LocalAtBrown/article-rec-db/"
documentation = "https://github.com/LocalAtBrown/article-rec-db/"
packages = [{ include = "article_rec_db" }]

[tool.poetry.dependencies]
python = ">= 3.9, <3.12"
sqlmodel = "^0.0.14"
pydantic = "^2.5.0"
sqlalchemy = "^2.0.0"
psycopg2 = "^2.9.9"
pgvector = "^0.2.3"
numpy = "^1.26.1"

[tool.poetry.group.dev.dependencies]
alembic = "^1.12.1"
mypy = "^1.6.1"
pre-commit = "^3.5.0"
pytest = "^7.4.3"
poethepoet = "^0.24.2"
alembic-postgresql-enum = "^0.3.0"

[tool.poe.tasks.test]
help = "Run the test suite"
sequence = ["lclstart", "_lclwait", "_pytest", "lclstop"]
ignore_fail = "return_non_zero"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
include = '\.pyi?$'
line-length = 122
exclude = '''
(
  /(                        # exclude a few common directories in the
    \.git                   # root of the project
    | \.pytest_cache
    | python-venv
    | \.venv
    | build
    | dist
    | \.tox
  ))
'''

[tool.isort]
profile = "black"

[tool.mypy]
# use the strict option since this a new project
strict = true
implicit_reexport = true
files = "."
exclude = ['\.venv', 'tests', 'alembic']

# Poe task definitions
[tool.poe]
envfile = ".env"

[tool.poe.tasks.format]
help = "Run formatting pre-commit hooks"
shell = "pre-commit run --all-files; terraform fmt -recursive"

[tool.poe.tasks.lclstart]
help = "Start a local postgres container in the background"
shell = "docker run -d --rm --name postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_HOST_AUTH_METHOD=trust -p 127.0.0.1:5432:5432/tcp ankane/pgvector"

[tool.poe.tasks.lclstop]
help = "Stop the local postgres container running in the background"
shell = "docker stop postgres"

[tool.poe.tasks._lclwait]
help = "Wait for the local postgres container to be ready, since docker run returns before postgres is actually ready"
env = { SLEEP_SECONDS = "2" }
shell = """
until timeout 3 psql -h 127.0.0.1 -U postgres -c "select 1" -d postgres 2>&0>/dev/null
do
  printf "Waiting %s seconds for PostgreSQL to come up: %s@%s/%s...\n" $SLEEP_SECONDS postgres 127.0.0.1 postgres
  sleep $SLEEP_SECONDS;
done
"""

[tool.poe.tasks._pytest]
cmd = "pytest tests"

[tool.poe.tasks.lclconnect]
help = "Connect to the local postgres database"
cmd = "psql -h 127.0.0.1 -U postgres -d postgres"

[tool.poe.tasks.rmtdiff]
help = "Generate an Alemic migration script by diffing local changes against the remote database"
env = { DB_PORT = "5432" }
args = [
  { name = "stage", positional = true, help = "The name of the remote database to connect to", required = true },
  { name = "message", "options" = [
    "-m",
    "--message",
  ], help = "The message to use for the migration", required = true },
]
shell = """
PARAMS=$(aws ssm get-parameter --name "$DB_CREDENTIALS_SSM_PARAM" --with-decryption --query "Parameter.Value" --output text)
HOST=$(echo $PARAMS | jq -r '.host')
USERNAME=$(echo $PARAMS | jq -r '.username')
PASSWORD=$(echo $PARAMS | jq -r '.password')
DB_CONNECTION_STRING=postgresql://$USERNAME:$PASSWORD@$HOST:$DB_PORT/$stage alembic revision --autogenerate -m "$message"
"""

[tool.poe.tasks.rmtupgrade]
help = "Upgrade the remote database to the latest revision"
env = { DB_PORT = "5432" }
args = [
  { name = "stage", positional = true, help = "The name of the remote database to connect to", required = true },
]
shell = """
PARAMS=$(aws ssm get-parameter --name "$DB_CREDENTIALS_SSM_PARAM" --with-decryption --query "Parameter.Value" --output text)
HOST=$(echo $PARAMS | jq -r '.host')
USERNAME=$(echo $PARAMS | jq -r '.username')
PASSWORD=$(echo $PARAMS | jq -r '.password')
DB_CONNECTION_STRING=postgresql://$USERNAME:$PASSWORD@$HOST:$DB_PORT/$stage alembic upgrade head
"""

[tool.poe.tasks.terraform]
help = "Go to a stage directory and run a terraform command (init, plan, apply, destroy)"
args = [
  { name = "stage", positional = true, help = "The name of the stage to run terraform in", required = true },
  { name = "command", positional = true, help = "The terraform command to run", required = true },
]
cmd = "terraform -chdir=terraform/stages/$stage $command"
