# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.configured_transformation_execution import ConfiguredTransformationExecution
from ...types.configured_transformation_item import ConfiguredTransformationItem
from ...types.data_sink_create import DataSinkCreate
from ...types.data_source_create import DataSourceCreate
from ...types.data_source_managed_ingestion_execution import DataSourceManagedIngestionExecution
from ...types.eval_dataset_execution import EvalDatasetExecution
from ...types.eval_execution_params import EvalExecutionParams
from ...types.eval_question_result import EvalQuestionResult
from ...types.http_validation_error import HttpValidationError
from ...types.loaded_file import LoadedFile
from ...types.loaded_file_managed_ingestion_execution import LoadedFileManagedIngestionExecution
from ...types.pipeline import Pipeline
from ...types.pipeline_managed_ingestion_execution import PipelineManagedIngestionExecution
from ...types.preset_retrieval_params import PresetRetrievalParams
from ...types.text_node import TextNode

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class PipelineClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_pipeline_by_name(self, *, pipeline_name: str, project_name: str) -> typing.List[Pipeline]:
        """
        Get a pipeline by name.

        Parameters:
            - pipeline_name: str.

            - project_name: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_pipeline_by_name(
            pipeline_name="pipeline-name",
            project_name="project-name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/pipeline"),
            params=remove_none_from_dict({"pipeline_name": pipeline_name, "project_name": project_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Pipeline], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_pipeline_for_project(self, pipeline_id: str) -> Pipeline:
        """
        Get a pipeline by ID for a given project.

        Parameters:
            - pipeline_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_existing_pipeline(
        self,
        pipeline_id: str,
        *,
        configured_transformations: typing.Optional[typing.List[ConfiguredTransformationItem]] = OMIT,
        data_source_ids: typing.Optional[typing.List[str]] = OMIT,
        data_sources: typing.Optional[typing.List[DataSourceCreate]] = OMIT,
        data_sink_ids: typing.Optional[typing.List[str]] = OMIT,
        data_sinks: typing.Optional[typing.List[DataSinkCreate]] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        name: typing.Optional[str] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
    ) -> Pipeline:
        """
        Update an existing pipeline for a project.

        Parameters:
            - pipeline_id: str.

            - configured_transformations: typing.Optional[typing.List[ConfiguredTransformationItem]].

            - data_source_ids: typing.Optional[typing.List[str]]. List of data source IDs. When provided instead of data_sources, the data sources will be looked up by ID.

            - data_sources: typing.Optional[typing.List[DataSourceCreate]]. List of data sources. When provided instead of data_source_ids, the data sources will be created.

            - data_sink_ids: typing.Optional[typing.List[str]]. List of data sink IDs. When provided instead of data_sinks, the data sinks will be looked up by ID.

            - data_sinks: typing.Optional[typing.List[DataSinkCreate]]. List of data sinks. When provided instead of data_sink_ids, the data sinks will be created.

            - preset_retrieval_parameters: typing.Optional[PresetRetrievalParams]. Preset retrieval parameters for the pipeline.

            - name: typing.Optional[str].

            - managed_pipeline_id: typing.Optional[str]. The ID of the ManagedPipeline this playground pipeline is linked to.
        """
        _request: typing.Dict[str, typing.Any] = {}
        if configured_transformations is not OMIT:
            _request["configured_transformations"] = configured_transformations
        if data_source_ids is not OMIT:
            _request["data_source_ids"] = data_source_ids
        if data_sources is not OMIT:
            _request["data_sources"] = data_sources
        if data_sink_ids is not OMIT:
            _request["data_sink_ids"] = data_sink_ids
        if data_sinks is not OMIT:
            _request["data_sinks"] = data_sinks
        if preset_retrieval_parameters is not OMIT:
            _request["preset_retrieval_parameters"] = preset_retrieval_parameters
        if name is not OMIT:
            _request["name"] = name
        if managed_pipeline_id is not OMIT:
            _request["managed_pipeline_id"] = managed_pipeline_id
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_pipeline(self, pipeline_id: str) -> None:
        """
        Delete a pipeline by ID.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.delete_pipeline(
            pipeline_id="pipeline-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_loaded_files_for_pipeline(self, pipeline_id: str) -> typing.List[LoadedFile]:
        """
        Get loaded files for a pipeline by ID.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_loaded_files_for_pipeline(
            pipeline_id="pipeline-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/file"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LoadedFile], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def deploy_playground_pipeline(
        self, pipeline_id: str, *, managed_pipeline_name: typing.Optional[str] = None
    ) -> Pipeline:
        """
        Deploy a playground pipeline to a managed pipeline.

        Parameters:
            - pipeline_id: str.

            - managed_pipeline_name: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/deploy"),
            params=remove_none_from_dict({"managed_pipeline_name": managed_pipeline_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def deploy_playground_pipeline_with_existing_managed_pipeline(self, pipeline_id: str) -> Pipeline:
        """
        Deploy a playground pipeline to the managed pipeline it is already associated with.

        Parameters:
            - pipeline_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/deploy"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_playground_pipeline(
        self, pipeline_id: str, *, playground_pipeline_name: typing.Optional[str] = None
    ) -> Pipeline:
        """
        Create a playground pipeline from a managed pipeline.

        Parameters:
            - pipeline_id: str.

            - playground_pipeline_name: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/playground"),
            params=remove_none_from_dict({"playground_pipeline_name": playground_pipeline_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_all_configured_transformation_executions(
        self, pipeline_id: str
    ) -> typing.List[ConfiguredTransformationExecution]:
        """
        Get all ConfiguredTransformationExecutions for a given pipeline.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_all_configured_transformation_executions(
            pipeline_id="pipeline-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ConfiguredTransformationExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_configured_transformation_execution(
        self,
        pipeline_id: str,
        *,
        configured_transformation_execution_id: typing.Optional[str] = None,
        loaded_file_ids: typing.Optional[typing.Union[str, typing.List[str]]] = None,
    ) -> ConfiguredTransformationExecution:
        """
        Kick off a new ConfiguredTransformation execution.
        Can optionally supply a configured_transformation_execution_id to run a specific execution.
        In absense of a configured_transformation_execution_id, the last
        configured_transformation_execution will be run (which may end up triggering runs
        for it's prior steps as well)

        Parameters:
            - pipeline_id: str.

            - configured_transformation_execution_id: typing.Optional[str].

            - loaded_file_ids: typing.Optional[typing.Union[str, typing.List[str]]].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution",
            ),
            params=remove_none_from_dict(
                {
                    "configured_transformation_execution_id": configured_transformation_execution_id,
                    "loaded_file_ids": loaded_file_ids,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfiguredTransformationExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_configured_transformation_execution(
        self, pipeline_id: str, configured_transformation_execution_id: str
    ) -> ConfiguredTransformationExecution:
        """
        Get status of a single pipeline ConfiguredTransformationExecution for a given pipeline.

        Parameters:
            - pipeline_id: str.

            - configured_transformation_execution_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution/{configured_transformation_execution_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfiguredTransformationExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_configured_transformation_result(
        self, pipeline_id: str, configured_transformation_id: str
    ) -> typing.List[TextNode]:
        """
        Get the result of an ConfiguredTransformationExecution step.
        Unlike get_configured_transformation_execution_result, this endpoint does
        not check the status of the execution that produced the result for the
        configured_transformation.

        Parameters:
            - pipeline_id: str.

            - configured_transformation_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_configured_transformation_result(
            pipeline_id="pipeline-id",
            configured_transformation_id="configured-transformation-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation/{configured_transformation_id}/result",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TextNode], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_dataset_executions(self, pipeline_id: str, eval_dataset_id: str) -> typing.List[EvalDatasetExecution]:
        """
        Get the status of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_eval_dataset_executions(
            pipeline_id="pipeline-id",
            eval_dataset_id="eval-dataset-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvalDatasetExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute_eval_dataset(
        self,
        pipeline_id: str,
        eval_dataset_id: str,
        *,
        eval_question_ids: typing.List[str],
        params: EvalExecutionParams,
    ) -> EvalDatasetExecution:
        """
        Execute a dataset.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.

            - eval_question_ids: typing.List[str].

            - params: EvalExecutionParams.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute",
            ),
            json=jsonable_encoder({"eval_question_ids": eval_question_ids, "params": params}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvalDatasetExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_dataset_execution_result(
        self, pipeline_id: str, eval_dataset_id: str
    ) -> typing.List[EvalQuestionResult]:
        """
        Get the result of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_eval_dataset_execution_result(
            pipeline_id="pipeline-id",
            eval_dataset_id="eval-dataset-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute/result",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvalQuestionResult], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_eval_dataset_execution(
        self, pipeline_id: str, eval_dataset_id: str, eval_dataset_execution_id: str
    ) -> EvalDatasetExecution:
        """
        Get the status of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.

            - eval_dataset_execution_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute/{eval_dataset_execution_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvalDatasetExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_loaded_file_ingestion_executions(
        self, pipeline_id: str, loaded_file_id: str
    ) -> typing.List[LoadedFileManagedIngestionExecution]:
        """
        Get all ManagedLoadedFileIngestionExecution for a given pipeline and loaded file.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_managed_loaded_file_ingestion_executions(
            pipeline_id="pipeline-id",
            loaded_file_id="loaded-file-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LoadedFileManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_managed_loaded_file_ingestion(
        self, pipeline_id: str, loaded_file_id: str
    ) -> LoadedFileManagedIngestionExecution:
        """
        Execute a ManagedLoadedFileIngestion.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LoadedFileManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_loaded_file_ingestion_execution(
        self, pipeline_id: str, loaded_file_id: str, managed_loaded_file_ingestion_id: str
    ) -> LoadedFileManagedIngestionExecution:
        """
        Get a single ManagedLoadedFileIngestionExecution for a given pipeline and loaded file.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.

            - managed_loaded_file_ingestion_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest/{managed_loaded_file_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LoadedFileManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_data_source_ingestion_executions(
        self, pipeline_id: str, data_source_id: str
    ) -> typing.List[DataSourceManagedIngestionExecution]:
        """
        Get all ManagedDataSourceIngestionExecution for a given pipeline and data source.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_managed_data_source_ingestion_executions(
            pipeline_id="pipeline-id",
            data_source_id="data-source-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[DataSourceManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_managed_data_source_ingestion(
        self, pipeline_id: str, data_source_id: str
    ) -> DataSourceManagedIngestionExecution:
        """
        Execute a ManagedDataSourceIngestion.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DataSourceManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_data_source_ingestion_execution(
        self, pipeline_id: str, data_source_id: str, managed_data_source_ingestion_id: str
    ) -> DataSourceManagedIngestionExecution:
        """
        Get a single ManagedDataSourceIngestionExecution for a given pipeline and data source.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.

            - managed_data_source_ingestion_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest/{managed_data_source_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DataSourceManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_pipeline_ingestion_executions(
        self, pipeline_id: str
    ) -> typing.List[PipelineManagedIngestionExecution]:
        """
        Get all ManagedPipelineIngestionExecution for a given pipeline.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import PlatformApi

        client = PlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.pipeline.get_managed_pipeline_ingestion_executions(
            pipeline_id="pipeline-id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/managed_ingest"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[PipelineManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_managed_pipeline_ingestion(self, pipeline_id: str) -> PipelineManagedIngestionExecution:
        """
        Execute a ManagedPipelineIngestion.

        Parameters:
            - pipeline_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/managed_ingest"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PipelineManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_managed_ingestion_execution(
        self, pipeline_id: str, managed_pipeline_ingestion_id: str
    ) -> PipelineManagedIngestionExecution:
        """
        Parameters:
            - pipeline_id: str.

            - managed_pipeline_ingestion_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/managed_ingest/{managed_pipeline_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PipelineManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncPipelineClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_pipeline_by_name(self, *, pipeline_name: str, project_name: str) -> typing.List[Pipeline]:
        """
        Get a pipeline by name.

        Parameters:
            - pipeline_name: str.

            - project_name: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_pipeline_by_name(
            pipeline_name="pipeline-name",
            project_name="project-name",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/pipeline"),
            params=remove_none_from_dict({"pipeline_name": pipeline_name, "project_name": project_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Pipeline], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_pipeline_for_project(self, pipeline_id: str) -> Pipeline:
        """
        Get a pipeline by ID for a given project.

        Parameters:
            - pipeline_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_existing_pipeline(
        self,
        pipeline_id: str,
        *,
        configured_transformations: typing.Optional[typing.List[ConfiguredTransformationItem]] = OMIT,
        data_source_ids: typing.Optional[typing.List[str]] = OMIT,
        data_sources: typing.Optional[typing.List[DataSourceCreate]] = OMIT,
        data_sink_ids: typing.Optional[typing.List[str]] = OMIT,
        data_sinks: typing.Optional[typing.List[DataSinkCreate]] = OMIT,
        preset_retrieval_parameters: typing.Optional[PresetRetrievalParams] = OMIT,
        name: typing.Optional[str] = OMIT,
        managed_pipeline_id: typing.Optional[str] = OMIT,
    ) -> Pipeline:
        """
        Update an existing pipeline for a project.

        Parameters:
            - pipeline_id: str.

            - configured_transformations: typing.Optional[typing.List[ConfiguredTransformationItem]].

            - data_source_ids: typing.Optional[typing.List[str]]. List of data source IDs. When provided instead of data_sources, the data sources will be looked up by ID.

            - data_sources: typing.Optional[typing.List[DataSourceCreate]]. List of data sources. When provided instead of data_source_ids, the data sources will be created.

            - data_sink_ids: typing.Optional[typing.List[str]]. List of data sink IDs. When provided instead of data_sinks, the data sinks will be looked up by ID.

            - data_sinks: typing.Optional[typing.List[DataSinkCreate]]. List of data sinks. When provided instead of data_sink_ids, the data sinks will be created.

            - preset_retrieval_parameters: typing.Optional[PresetRetrievalParams]. Preset retrieval parameters for the pipeline.

            - name: typing.Optional[str].

            - managed_pipeline_id: typing.Optional[str]. The ID of the ManagedPipeline this playground pipeline is linked to.
        """
        _request: typing.Dict[str, typing.Any] = {}
        if configured_transformations is not OMIT:
            _request["configured_transformations"] = configured_transformations
        if data_source_ids is not OMIT:
            _request["data_source_ids"] = data_source_ids
        if data_sources is not OMIT:
            _request["data_sources"] = data_sources
        if data_sink_ids is not OMIT:
            _request["data_sink_ids"] = data_sink_ids
        if data_sinks is not OMIT:
            _request["data_sinks"] = data_sinks
        if preset_retrieval_parameters is not OMIT:
            _request["preset_retrieval_parameters"] = preset_retrieval_parameters
        if name is not OMIT:
            _request["name"] = name
        if managed_pipeline_id is not OMIT:
            _request["managed_pipeline_id"] = managed_pipeline_id
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_pipeline(self, pipeline_id: str) -> None:
        """
        Delete a pipeline by ID.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.delete_pipeline(
            pipeline_id="pipeline-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_loaded_files_for_pipeline(self, pipeline_id: str) -> typing.List[LoadedFile]:
        """
        Get loaded files for a pipeline by ID.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_loaded_files_for_pipeline(
            pipeline_id="pipeline-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/file"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LoadedFile], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def deploy_playground_pipeline(
        self, pipeline_id: str, *, managed_pipeline_name: typing.Optional[str] = None
    ) -> Pipeline:
        """
        Deploy a playground pipeline to a managed pipeline.

        Parameters:
            - pipeline_id: str.

            - managed_pipeline_name: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/deploy"),
            params=remove_none_from_dict({"managed_pipeline_name": managed_pipeline_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def deploy_playground_pipeline_with_existing_managed_pipeline(self, pipeline_id: str) -> Pipeline:
        """
        Deploy a playground pipeline to the managed pipeline it is already associated with.

        Parameters:
            - pipeline_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/deploy"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_playground_pipeline(
        self, pipeline_id: str, *, playground_pipeline_name: typing.Optional[str] = None
    ) -> Pipeline:
        """
        Create a playground pipeline from a managed pipeline.

        Parameters:
            - pipeline_id: str.

            - playground_pipeline_name: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/playground"),
            params=remove_none_from_dict({"playground_pipeline_name": playground_pipeline_name}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Pipeline, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_all_configured_transformation_executions(
        self, pipeline_id: str
    ) -> typing.List[ConfiguredTransformationExecution]:
        """
        Get all ConfiguredTransformationExecutions for a given pipeline.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_all_configured_transformation_executions(
            pipeline_id="pipeline-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ConfiguredTransformationExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_configured_transformation_execution(
        self,
        pipeline_id: str,
        *,
        configured_transformation_execution_id: typing.Optional[str] = None,
        loaded_file_ids: typing.Optional[typing.Union[str, typing.List[str]]] = None,
    ) -> ConfiguredTransformationExecution:
        """
        Kick off a new ConfiguredTransformation execution.
        Can optionally supply a configured_transformation_execution_id to run a specific execution.
        In absense of a configured_transformation_execution_id, the last
        configured_transformation_execution will be run (which may end up triggering runs
        for it's prior steps as well)

        Parameters:
            - pipeline_id: str.

            - configured_transformation_execution_id: typing.Optional[str].

            - loaded_file_ids: typing.Optional[typing.Union[str, typing.List[str]]].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution",
            ),
            params=remove_none_from_dict(
                {
                    "configured_transformation_execution_id": configured_transformation_execution_id,
                    "loaded_file_ids": loaded_file_ids,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfiguredTransformationExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_configured_transformation_execution(
        self, pipeline_id: str, configured_transformation_execution_id: str
    ) -> ConfiguredTransformationExecution:
        """
        Get status of a single pipeline ConfiguredTransformationExecution for a given pipeline.

        Parameters:
            - pipeline_id: str.

            - configured_transformation_execution_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation_execution/{configured_transformation_execution_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConfiguredTransformationExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_configured_transformation_result(
        self, pipeline_id: str, configured_transformation_id: str
    ) -> typing.List[TextNode]:
        """
        Get the result of an ConfiguredTransformationExecution step.
        Unlike get_configured_transformation_execution_result, this endpoint does
        not check the status of the execution that produced the result for the
        configured_transformation.

        Parameters:
            - pipeline_id: str.

            - configured_transformation_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_configured_transformation_result(
            pipeline_id="pipeline-id",
            configured_transformation_id="configured-transformation-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/configured_transformation/{configured_transformation_id}/result",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[TextNode], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_dataset_executions(
        self, pipeline_id: str, eval_dataset_id: str
    ) -> typing.List[EvalDatasetExecution]:
        """
        Get the status of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_eval_dataset_executions(
            pipeline_id="pipeline-id",
            eval_dataset_id="eval-dataset-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvalDatasetExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute_eval_dataset(
        self,
        pipeline_id: str,
        eval_dataset_id: str,
        *,
        eval_question_ids: typing.List[str],
        params: EvalExecutionParams,
    ) -> EvalDatasetExecution:
        """
        Execute a dataset.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.

            - eval_question_ids: typing.List[str].

            - params: EvalExecutionParams.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute",
            ),
            json=jsonable_encoder({"eval_question_ids": eval_question_ids, "params": params}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvalDatasetExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_dataset_execution_result(
        self, pipeline_id: str, eval_dataset_id: str
    ) -> typing.List[EvalQuestionResult]:
        """
        Get the result of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_eval_dataset_execution_result(
            pipeline_id="pipeline-id",
            eval_dataset_id="eval-dataset-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute/result",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[EvalQuestionResult], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_eval_dataset_execution(
        self, pipeline_id: str, eval_dataset_id: str, eval_dataset_execution_id: str
    ) -> EvalDatasetExecution:
        """
        Get the status of an EvalDatasetExecution.

        Parameters:
            - pipeline_id: str.

            - eval_dataset_id: str.

            - eval_dataset_execution_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/eval_dataset/{eval_dataset_id}/execute/{eval_dataset_execution_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EvalDatasetExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_loaded_file_ingestion_executions(
        self, pipeline_id: str, loaded_file_id: str
    ) -> typing.List[LoadedFileManagedIngestionExecution]:
        """
        Get all ManagedLoadedFileIngestionExecution for a given pipeline and loaded file.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_managed_loaded_file_ingestion_executions(
            pipeline_id="pipeline-id",
            loaded_file_id="loaded-file-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LoadedFileManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_managed_loaded_file_ingestion(
        self, pipeline_id: str, loaded_file_id: str
    ) -> LoadedFileManagedIngestionExecution:
        """
        Execute a ManagedLoadedFileIngestion.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LoadedFileManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_loaded_file_ingestion_execution(
        self, pipeline_id: str, loaded_file_id: str, managed_loaded_file_ingestion_id: str
    ) -> LoadedFileManagedIngestionExecution:
        """
        Get a single ManagedLoadedFileIngestionExecution for a given pipeline and loaded file.

        Parameters:
            - pipeline_id: str.

            - loaded_file_id: str.

            - managed_loaded_file_ingestion_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/loaded_file/{loaded_file_id}/managed_ingest/{managed_loaded_file_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LoadedFileManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_data_source_ingestion_executions(
        self, pipeline_id: str, data_source_id: str
    ) -> typing.List[DataSourceManagedIngestionExecution]:
        """
        Get all ManagedDataSourceIngestionExecution for a given pipeline and data source.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_managed_data_source_ingestion_executions(
            pipeline_id="pipeline-id",
            data_source_id="data-source-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[DataSourceManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_managed_data_source_ingestion(
        self, pipeline_id: str, data_source_id: str
    ) -> DataSourceManagedIngestionExecution:
        """
        Execute a ManagedDataSourceIngestion.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DataSourceManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_data_source_ingestion_execution(
        self, pipeline_id: str, data_source_id: str, managed_data_source_ingestion_id: str
    ) -> DataSourceManagedIngestionExecution:
        """
        Get a single ManagedDataSourceIngestionExecution for a given pipeline and data source.

        Parameters:
            - pipeline_id: str.

            - data_source_id: str.

            - managed_data_source_ingestion_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/data_source/{data_source_id}/managed_ingest/{managed_data_source_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DataSourceManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_pipeline_ingestion_executions(
        self, pipeline_id: str
    ) -> typing.List[PipelineManagedIngestionExecution]:
        """
        Get all ManagedPipelineIngestionExecution for a given pipeline.

        Parameters:
            - pipeline_id: str.
        ---
        from platform.client import AsyncPlatformApi

        client = AsyncPlatformApi(
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        await client.pipeline.get_managed_pipeline_ingestion_executions(
            pipeline_id="pipeline-id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/managed_ingest"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[PipelineManagedIngestionExecution], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_managed_pipeline_ingestion(self, pipeline_id: str) -> PipelineManagedIngestionExecution:
        """
        Execute a ManagedPipelineIngestion.

        Parameters:
            - pipeline_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/pipeline/{pipeline_id}/managed_ingest"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PipelineManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_managed_ingestion_execution(
        self, pipeline_id: str, managed_pipeline_ingestion_id: str
    ) -> PipelineManagedIngestionExecution:
        """
        Parameters:
            - pipeline_id: str.

            - managed_pipeline_ingestion_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/pipeline/{pipeline_id}/managed_ingest/{managed_pipeline_ingestion_id}",
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PipelineManagedIngestionExecution, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
