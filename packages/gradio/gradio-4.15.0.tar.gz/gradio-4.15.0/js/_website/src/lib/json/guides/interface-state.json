{"guide": {"name": "interface-state", "category": "building-interfaces", "pretty_category": "Building Interfaces", "guide_index": 3, "absolute_index": 6, "pretty_name": "Interface State", "content": "# Interface State\n\nSo far, we've assumed that your demos are *stateless*: that they do not persist information beyond a single function call. What if you want to modify the behavior of your demo based on previous interactions with the demo? There are two approaches in Gradio: *global state* and *session state*.\n\n## Global State\n\nIf the state is something that should be accessible to all function calls and all users, you can create a variable outside the function call and access it inside the function. For example, you may load a large model outside the function and use it inside the function so that every function call does not need to reload the model.\n\n```python\nimport gradio as gr\n\nscores = []\n\ndef track_score(score):\n    scores.append(score)\n    top_scores = sorted(scores, reverse=True)[:3]\n    return top_scores\n\ndemo = gr.Interface(\n    track_score, \n    gr.Number(label=\"Score\"), \n    gr.JSON(label=\"Top Scores\")\n)\ndemo.launch()\n```\n\nIn the code above, the `scores` array is shared between all users. If multiple users are accessing this demo, their scores will all be added to the same list, and the returned top 3 scores will be collected from this shared reference.\n\n## Session State\n\nAnother type of data persistence Gradio supports is session state, where data persists across multiple submits within a page session. However, data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Pass in an extra parameter into your function, which represents the state of the interface.\n2. At the end of the function, return the updated value of the state as an extra return value.\n3. Add the `'state'` input and `'state'` output components when creating your `Interface`\n\nA chatbot is an example where you would need session state - you want access to a users previous submissions, but you cannot store chat history in a global variable, because then chat history would get jumbled between different users.\n\n```python\nimport gradio as gr\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nimport torch\n\ntokenizer = AutoTokenizer.from_pretrained(\"microsoft/DialoGPT-medium\")\nmodel = AutoModelForCausalLM.from_pretrained(\"microsoft/DialoGPT-medium\")\n\n\ndef user(message, history):\n    return \"\", history + [[message, None]]\n\n\ndef bot(history):\n    user_message = history[-1][0]\n    new_user_input_ids = tokenizer.encode(\n        user_message + tokenizer.eos_token, return_tensors=\"pt\"\n    )\n\n    # append the new user input tokens to the chat history\n    bot_input_ids = torch.cat([torch.LongTensor([]), new_user_input_ids], dim=-1)\n\n    # generate a response\n    response = model.generate(\n        bot_input_ids, max_length=1000, pad_token_id=tokenizer.eos_token_id\n    ).tolist()\n\n    # convert the tokens to text, and then split the responses into lines\n    response = tokenizer.decode(response[0]).split(\"<|endoftext|>\")\n    response = [\n        (response[i], response[i + 1]) for i in range(0, len(response) - 1, 2)\n    ]  # convert to tuples of list\n    history[-1] = response[0]\n    return history\n\n\nwith gr.Blocks() as demo:\n    chatbot = gr.Chatbot()\n    msg = gr.Textbox()\n    clear = gr.Button(\"Clear\")\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: None, None, chatbot, queue=False)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/chatbot_dialogpt'></gradio-app>\n\nNotice how the state persists across submits within each page, but if you load this demo in another tab (or refresh the page), the demos will not share chat history.\n\nThe default value of `state` is None. If you pass a default value to the state parameter of the function, it is used as the default value of the state instead. The `Interface` class only supports a single input and outputs state variable, though it can be a list with multiple elements. For more complex use cases, you can use Blocks, [which supports multiple `State` variables](/guides/state-in-blocks/).\n", "tags": [], "spaces": [], "url": "/guides/interface-state/", "contributor": null}}