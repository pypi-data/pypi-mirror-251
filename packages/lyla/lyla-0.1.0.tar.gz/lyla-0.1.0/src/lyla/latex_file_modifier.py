"""
General code for helping modify LaTeX files.
"""
import re
from pathlib import Path
from typing import Union, Any, Optional


def prepend_file_with_auto_generated_warning_message(file_to_prepend: Path, generator_file: Union[Path, None] = None):
    """
    Adds a message about the file being auto-generated to the beginning of a file.

    :param file_to_prepend: The file to prepend the message to
    :param generator_file: The optional path to the file which generated the file.
    """
    with file_to_prepend.open() as file_handle:
        file_lines = file_handle.readlines()
    prepend_lines = ['% WARNING! THIS FILE IS AUTO-GENERATED!\n',
                     '% Do not manually edit this file.\n',
                     '% Changes to this file will be overwritten by the next auto-generation.\n']
    if generator_file is not None:
        project_directory = generator_file.parent
        while not project_directory.joinpath("main.tex").exists():
            if project_directory == Path('/'):
                raise ValueError("No main.tex found before reaching root directory.")
            project_directory = project_directory.parent
        prepend_lines.append(f'% Edit the generating file instead.\n')
        prepend_lines.append(f'% This file was generated by `{generator_file.relative_to(project_directory)}`.\n')
    with file_to_prepend.open('w') as file_handle:
        lines = prepend_lines + file_lines
        file_handle.writelines(lines)


def generate_new_command_string(command_name: str, value: Any) -> str:
    new_command_string = '\\newcommand{\\' + command_name + '}{' + f'{value}' + '}\n'
    return new_command_string


def upsert_command_value_in_file(file_path: Path, command_name: str, value: Any) -> None:
    with file_path.open('r') as file_handle:
        lines = file_handle.readlines()
    upsert_command_value_in_lines(lines, command_name, value)
    with file_path.open('w') as file_handle:
        file_handle.writelines(lines)


def upsert_command_value_in_lines(lines, command_name, value):
    match_index = None
    for index, line in enumerate(lines):
        match = re.search(rf'\\newcommand{{\\{command_name}}}[^\\n]', line)
        if match is not None:
            match_index = index
            break
    new_command_string = generate_new_command_string(command_name, value)
    if match_index is not None:
        lines.pop(match_index)
        lines.insert(match_index, new_command_string)
    else:
        lines.append(new_command_string)
    return lines
