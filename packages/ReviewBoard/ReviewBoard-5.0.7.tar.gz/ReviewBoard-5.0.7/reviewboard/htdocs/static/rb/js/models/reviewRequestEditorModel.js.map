{"version":3,"file":"reviewRequestEditorModel.js","names":["RB","ReviewRequestEditor","Backbone","Model","extend","defaults","commitMessages","changeDescriptionRenderedText","closeDescriptionRenderedText","commentIssueManager","editable","editCount","hasDraft","fileAttachments","fileAttachmentComments","mutableByUser","pendingSaveCount","publishing","reviewRequest","screenshots","showSendEmail","statusEditable","statusMutableByUser","initialize","get","Collection","model","FileAttachment","set","listenTo","_onFileAttachmentOrScreenshotAdded","each","bind","Screenshot","draft","trigger","_computeEditable","parse","attrs","_","commits","DiffCommitCollection","createFileAttachment","attributes","fileAttachment","attachmentHistoryID","oldAttachment","findWhere","index","indexOf","remove","add","at","getDraftField","fieldName","options","useExtraData","data","useRawTextValue","rawTextFields","extra_data","setDraftField","value","context","undefined","isFunction","success","error","complete","console","warn","promiseToCallbacks","newOptions","jsonFieldName","assert","allowMarkdown","jsonTextTypeFieldName","richText","force_text_type","include_text_types","save","then","decr","publishDraft","err","message","rsp","xhr","errorPayload","fields","fieldValue","fieldValueLen","length","i","interpolate","ngettext","gettext","Promise","reject","ensureCreated","links","submitter","title","confirm","publish","trivial","incr","attr","isNumber","validate","strings","has","UNBALANCED_EDIT_COUNT","state","pending","ReviewRequest","PENDING","attachment"],"sources":["../../../../../static/rb/js/models/reviewRequestEditorModel.es6.js"],"sourcesContent":["/**\n * Handles all operations and state related to editing review requests.\n *\n * This manages the editing of all fields and objects on a review request,\n * the publishing workflow, and validation.\n *\n * Model Attributes:\n *     commits (RB.DiffCommitCollection):\n *         The collection of commits on this review request.\n *\n *     changeDescriptionRenderedText (string):\n *         The rendered change description text, if any.\n *\n *     closeDescriptionRenderedText (string):\n *         The rendered close description text, if any.\n *\n *     commentIssueManager (RB.CommentIssueManager):\n *         The issue manager for the editor.\n *\n *     editable (boolean):\n *         Whether or not the review request is currently editable.\n *\n *         This is derived from the ``mutableByUser`` attribute and the review\n *         request's ``state`` attribute.\n *\n *     editCount (number):\n *         The number of outstanding edits.\n *\n *     hasDraft (boolean):\n *         Whether or not a draft currently exists.\n *\n *     fileAttachemnts (Backbone.Collection of RB.FileAttachment):\n *         The files attached to this review request.\n *\n *     fileAttachmentComments (object):\n *         A mapping of file attachment IDs to their comments.\n *\n *     mutableByUser (boolean):\n *         Whether or not the user can mutate the review request.\n *\n *     pendingSaveCount (number):\n *         The number of fields that have yet to be saved.\n *\n *     publishing (boolean):\n *         Whether or not we are currently publishing the review request.\n *\n *     reviewRequest (RB.ReviewRequest):\n *         The review request model.\n *\n *     screenshots (Backbone.Collection of RB.Screenshot):\n *         The legacy screenshots attached to this review request.\n *\n *     showSendEmail (boolean):\n *         Whether or not to show the \"Send e-mail\" checkbox for this review\n *         request.\n *\n *     statusEditable (boolean):\n *         Whether or not the status is currently editable.\n *\n *     statusMutableByUser (boolean):\n *         Whether or not the status is mutable by the current user.\n */\nRB.ReviewRequestEditor = Backbone.Model.extend({\n    defaults() {\n        return {\n            commitMessages: [],\n            changeDescriptionRenderedText: '',\n            closeDescriptionRenderedText: '',\n            commentIssueManager: null,\n            editable: false,\n            editCount: 0,\n            hasDraft: false,\n            fileAttachments: null,\n            fileAttachmentComments: {},\n            mutableByUser: false,\n            pendingSaveCount: 0,\n            publishing: false,\n            reviewRequest: null,\n            screenshots: null,\n            showSendEmail: false,\n            statusEditable: false,\n            statusMutableByUser: false,\n        };\n    },\n\n    /**\n     * Initialize the editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        // Set up file attachments.\n        let fileAttachments = this.get('fileAttachments');\n\n        if (fileAttachments === null) {\n            fileAttachments = new Backbone.Collection([], {\n                model: RB.FileAttachment,\n            });\n            this.set('fileAttachments', fileAttachments);\n        }\n\n        this.listenTo(fileAttachments, 'add',\n                      this._onFileAttachmentOrScreenshotAdded);\n        fileAttachments.each(\n            this._onFileAttachmentOrScreenshotAdded.bind(this));\n\n        // Set up screenshots.\n        let screenshots = this.get('screenshots');\n\n        if (screenshots === null) {\n            screenshots = new Backbone.Collection([], {\n                model: RB.Screenshot,\n            });\n            this.set('screenshots', screenshots);\n        }\n\n        this.listenTo(screenshots, 'add',\n                      this._onFileAttachmentOrScreenshotAdded);\n        screenshots.each(\n            this._onFileAttachmentOrScreenshotAdded.bind(this));\n\n        // Connect to other signals.\n        this.listenTo(reviewRequest.draft, 'saving',\n                      () => this.trigger('saving'));\n        this.listenTo(reviewRequest.draft, 'saved',\n                      () => this.trigger('saved'));\n        this.listenTo(reviewRequest, 'change:state', this._computeEditable);\n        this._computeEditable();\n    },\n\n    /**\n     * Parse the given attributes into model attributes.\n     *\n     * Args:\n     *     attrs (object):\n     *        The attributes to parse.\n     *\n     * Returns:\n     *     object:\n     *     The parsed attributes.\n     */\n    parse(attrs) {\n        return _.defaults({\n            commits: new RB.DiffCommitCollection(\n                attrs.commits || [],\n                {parse: true}\n            ),\n        }, attrs);\n    },\n\n    /**\n     * Create a file attachment tracked by the editor.\n     *\n     * This wraps RB.ReviewRequestDraft.createFileAttachment and stores the\n     * file attachment in the fileAttachments collection.\n     *\n     * This should be used instead of\n     * RB.ReviewRequestDraft.createFileAttachment for any existing or newly\n     * uploaded file attachments.\n     *\n     * Args:\n     *     attributes (object, optional):\n     *         Model attributes for the new file attachment.\n     *\n     * Returns:\n     *     RB.FileAttachment:\n     *     The new file attachment model.\n     */\n    createFileAttachment(attributes={}) {\n        const draft = this.get('reviewRequest').draft;\n        const fileAttachment = draft.createFileAttachment(attributes);\n\n        const fileAttachments = this.get('fileAttachments');\n\n        if (attributes.attachmentHistoryID) {\n            const oldAttachment = fileAttachments.findWhere({\n                attachmentHistoryID: attributes.attachmentHistoryID,\n            });\n            const index = fileAttachments.indexOf(oldAttachment);\n\n            fileAttachments.remove(oldAttachment);\n            fileAttachments.add(fileAttachment, { at: index, });\n        } else {\n            fileAttachments.add(fileAttachment);\n        }\n\n        return fileAttachment;\n    },\n\n    /**\n     * Return a field from the draft.\n     *\n     * This will look either in the draft's data or in the extraData (for\n     * custom fields), returning the value provided either when the page\n     * was generated or when it was last edited.\n     *\n     * Args:\n     *     fieldName (string):\n     *         The name of the field to get.\n     *\n     *     options (object, optional):\n     *         Options for the operation.\n     *\n     * Option Args:\n     *     jsonFieldName (string, optional):\n     *         The key to use for the field name in the API. This is required\n     *         if ``useExtraData`` is set.\n     *\n     *     useExtraData (boolean, optional):\n     *         Whether the field is stored as part of the extraData or is a\n     *         regular attribute. This requires ``jsonFieldName`` to be set.\n     *\n     *     useRawTextValue (boolean, optional):\n     *         Whether to return the raw text value for a field. This requires\n     *         ``useExtraData`` to be set to ``true``.\n     *\n     * Returns:\n     *     *:\n     *     The value of the field.\n     */\n    getDraftField(fieldName, options={}) {\n        const reviewRequest = this.get('reviewRequest');\n        const draft = reviewRequest.draft;\n\n        if (options.useExtraData) {\n            let data;\n\n            if (options.useRawTextValue) {\n                const rawTextFields = draft.get('rawTextFields');\n\n                if (rawTextFields && rawTextFields.extra_data) {\n                    data = rawTextFields.extra_data;\n                }\n            }\n\n            if (!data) {\n                data = draft.get('extraData');\n            }\n\n            return data[fieldName];\n        } else if (fieldName === 'closeDescription' ||\n                   fieldName === 'closeDescriptionRichText') {\n            return reviewRequest.get(fieldName);\n        } else {\n            return draft.get(fieldName);\n        }\n    },\n\n    /**\n     * Set a field in the draft.\n     *\n     * If we're in the process of publishing, this will check if we have saved\n     * all fields before publishing the draft.\n     *\n     * Once the field has been saved, two events will be triggered:\n     *\n     *     * fieldChanged(fieldName, value)\n     *     * fieldChanged:<fieldName>(value)\n     *\n     * Version Changed:\n     *     5.0:\n     *     Deprecated callbacks and added a promise return value.\n     *\n     * Args:\n     *     fieldName (string):\n     *         The name of the field to set.\n     *\n     *     value (*):\n     *         The value to set in the field.\n     *\n     *     options (object, optional):\n     *         Options for the set operation.\n     *\n     *     context (object, optional):\n     *         Context to bind when calling callbacks.\n     *\n     * Option Args:\n     *     allowMarkdown (boolean, optional):\n     *         Whether the field can support rich text (Markdown).\n     *         This requires that ``jsonTextTypeFieldName`` is set.\n     *\n     *     jsonFieldName (string):\n     *         The key to use for the field name in the API. This is required.\n     *\n     *     jsonTextTypeFieldName (string, optional):\n     *         The key to use for the name of the field indicating the text\n     *         type (rich text or plain) in the API.\n     *\n     *     richText (boolean, optional):\n     *         Whether the field is rich text (Markdown) formatted.\n     *\n     *     useExtraData (boolean, optional):\n     *         Whether the field should be set as a key in extraData or as a\n     *         direct attribute.\n     *\n     * Returns:\n     *     Promise:\n     *     A promise which resolves when the operation is complete.\n     */\n    setDraftField: function(fieldName, value, options={}, context=undefined) {\n        if (_.isFunction(options.success) ||\n            _.isFunction(options.error) ||\n            _.isFunction(options.complete)) {\n            console.warn('RB.ReviewRequestEditor.setDraftField was called ' +\n                         'using callbacks. Callers should be updated to ' +\n                         'use promises instead.');\n            return RB.promiseToCallbacks(\n                options, context,\n                newOptions => this.setDraftField(fieldName, value, newOptions));\n        }\n\n        const reviewRequest = this.get('reviewRequest');\n        const data = {};\n\n        let jsonFieldName = options.jsonFieldName;\n\n        console.assert(\n            jsonFieldName,\n            `jsonFieldName must be set when setting draft ` +\n            `field \"${fieldName}\".`);\n\n        if (options.useExtraData) {\n            jsonFieldName = `extra_data.${jsonFieldName}`;\n        }\n\n        if (options.allowMarkdown) {\n            let jsonTextTypeFieldName = options.jsonTextTypeFieldName;\n\n            console.assert(jsonTextTypeFieldName,\n                           'jsonTextTypeFieldName must be set.');\n\n            if (options.useExtraData) {\n                jsonTextTypeFieldName = `extra_data.${jsonTextTypeFieldName}`;\n            }\n\n            const richText = !!options.richText;\n            data[jsonTextTypeFieldName] = richText ? 'markdown' : 'plain';\n\n            data.force_text_type = 'html';\n            data.include_text_types = 'raw';\n        }\n\n        data[jsonFieldName] = value;\n\n        return reviewRequest.draft.save({ data }).then(\n            () => {\n                this.set('hasDraft', true);\n\n                this.trigger('fieldChanged:' + fieldName, value);\n                this.trigger('fieldChanged', fieldName, value);\n\n                if (this.get('publishing')) {\n                    this.decr('pendingSaveCount');\n\n                    if (this.get('pendingSaveCount') === 0) {\n                        this.set('publishing', false);\n                        this.publishDraft();\n                    }\n                }\n            },\n            err => {\n                let message = '';\n\n                this.set('publishing', false);\n\n                const rsp = err.xhr.errorPayload;\n\n                /*\n                 * An error can be caused by a 503 when the site is in\n                 * read-only mode, in which case the fields will be\n                 * empty.\n                 */\n                if (rsp.fields !== undefined) {\n                    const fieldValue = rsp.fields[jsonFieldName];\n                    const fieldValueLen = fieldValue.length;\n\n                    /* Wrap each term in quotes or a leading 'and'. */\n                    _.each(fieldValue, (value, i) => {\n                        // XXX: This method isn't localizable.\n                        if (i === fieldValueLen - 1 && fieldValueLen > 1) {\n                            if (i > 2) {\n                                message += ', ';\n                            }\n\n                            message += ` and \"${value}\"`;\n                        } else {\n                            if (i > 0) {\n                                message += ', ';\n                            }\n\n                            message += `\"${value}\"`;\n                        }\n                    });\n\n                    if (fieldName === 'targetGroups') {\n                        message = interpolate(\n                            ngettext('Group %s does not exist.',\n                                     'Groups %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    } else if (fieldName === 'targetPeople') {\n                        message = interpolate(\n                            ngettext('User %s does not exist.',\n                                     'Users %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    } else if (fieldName === 'submitter') {\n                        message = interpolate(\n                            gettext('User %s does not exist.'),\n                            [message]);\n                    } else if (fieldName === 'dependsOn') {\n                        message = interpolate(\n                            ngettext('Review Request %s does not exist.',\n                                     'Review Requests %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    }\n                }\n\n                err.message = message;\n                return Promise.reject(err);\n            });\n    },\n\n    /**\n     * Publish the draft to the server.\n     *\n     * This assumes all fields have been saved.\n     *\n     * If there's an error during saving or validation, the \"publishError\"\n     * event will be triggered with the error message. Otherwise, upon\n     * success, the \"publish\" event will be triggered. However, users will\n     * have the chance to cancel the publish in the event that the submitter\n     * has been changed.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the publish operation.\n     *\n     * Option Args:\n     *     trivial (boolean):\n     *         Whether the publish is \"trivial\" (if true, no e-mail\n     *         notifications will be sent).\n     */\n    async publishDraft(options={}) {\n        const reviewRequest = this.get('reviewRequest');\n\n        try {\n            await reviewRequest.draft.ensureCreated();\n\n            if (reviewRequest.attributes.links.submitter.title !==\n                reviewRequest.draft.attributes.links.submitter.title) {\n                if (!confirm(gettext('Are you sure you want to change the ownership of this review request? Doing so may prevent you from editing the review request afterwards.'))) {\n                    return;\n                }\n            }\n\n            await reviewRequest.draft.publish({\n                trivial: options.trivial ? 1 : 0,\n            });\n            this.trigger('published');\n        } catch (err) {\n            this.trigger('publishError', err.message);\n        }\n    },\n\n    /**\n     * Increment an attribute by 1.\n     *\n     * The attribute must be an integer.\n     *\n     * Args:\n     *     attr (string):\n     *         The name of the attribute to increment.\n     */\n    incr(attr) {\n        const value = this.get(attr);\n        console.assert(_.isNumber(value));\n        this.set(attr, value + 1, {\n            validate: true,\n        });\n    },\n\n    /**\n     * Decrement an attribute by 1.\n     *\n     * The attribute must be an integer.\n     *\n     * Args:\n     *     attr (string):\n     *         The name of the attribute to decrement.\n     */\n    decr(attr) {\n        const value = this.get(attr);\n        console.assert(_.isNumber(value));\n        this.set(attr, value - 1, {\n            validate: true,\n        });\n    },\n\n    /**\n     * Validate the given attributes.\n     *\n     * Args:\n     *     attrs (object):\n     *         The attributes to validate.\n     */\n    validate(attrs) {\n        const strings = RB.ReviewRequestEditor.strings;\n\n        if (_.has(attrs, 'editCount') && attrs.editCount < 0) {\n            return strings.UNBALANCED_EDIT_COUNT;\n        }\n    },\n\n    /**\n     * Compute the editable state of the review request and open/close states.\n     *\n     * The review request is editable if the user has edit permissions and it's\n     * not closed.\n     *\n     * The close state and accompanying description is editable if the user\n     * has the ability to close the review request and it's currently closed.\n     */\n    _computeEditable() {\n        const state = this.get('reviewRequest').get('state');\n        const pending = (state === RB.ReviewRequest.PENDING);\n\n        this.set({\n            editable: this.get('mutableByUser') && pending,\n            statusEditable: this.get('statusMutableByUser') && !pending,\n        });\n    },\n\n    /**\n     * Handle when a FileAttachment or Screenshot is added.\n     *\n     * Listens for events on the FileAttachment or Screenshot and relays\n     * them to the editor.\n     *\n     * Args:\n     *     attachment (RB.FileAttachment or RB.Screenshot):\n     *         The new file attachment or screenshot.\n     */\n    _onFileAttachmentOrScreenshotAdded(attachment) {\n        this.listenTo(attachment, 'saving',\n                      () => this.trigger('saving'));\n\n        this.listenTo(attachment, 'saved destroy', () => {\n            this.set('hasDraft', true);\n            this.trigger('saved');\n        });\n    },\n}, {\n    strings: {\n        UNBALANCED_EDIT_COUNT:\n            gettext('There is an internal error balancing the edit count'),\n    },\n});\n"],"mappings":"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"}