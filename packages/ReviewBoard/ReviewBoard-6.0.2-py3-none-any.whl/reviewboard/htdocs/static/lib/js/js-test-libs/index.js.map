{"version":3,"file":"index.js","sources":["../../../../../../node_modules/@beanbag/jasmine-suites/lib/index.js","../../../../../static/lib/js/js-test-libs/index.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jasmine')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'jasmine'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JasmineSuites = {}));\n})(this, (function (exports) { 'use strict';\n\n    /*\n     * Jasmine Suites 2.0.\n     *\n     * This offers namespaced test suites for Jasmine 4.6+.\n     *\n     * Copyright (C) 2016 Beanbag, Inc.\n     *\n     * Licensed under the MIT license.\n     */\n    console.assert(jasmine && jasmine.SuiteBuilder && jasmine.SuiteBuilder.prototype.addSpecsToSuite_, 'jasmine-suites is not compatible with this version of Jasmine');\n    let _curSuiteObj = null;\n    let _rootSuite = null;\n\n    /*\n     * Information on a suite of tests.\n     *\n     * This is a fancy generator for Jasmine describe() calls, which allows for\n     * taking a '/'-separated namespace of names and generating nested test suites.\n     *\n     * Subsequent calls that reuse any of these paths will have their tests added\n     * to the suite. This makes it very easy to organize tests, making it much\n     * easier to run subsets of tests across many files.\n     */\n    const SuiteInfo = function (description) {\n      this.description = description;\n      this.specs = null;\n      this.children = {};\n      this._added = false;\n      this._suiteObj = null;\n    };\n\n    /*\n     * Returns a SuiteInfo for a key, creating one if necessary.\n     *\n     * The SuiteInfo will be added to this suite's list of children.\n     */\n    SuiteInfo.prototype.getOrCreate = function (key, description) {\n      var suite = this.children[key];\n      if (!suite) {\n        suite = new SuiteInfo(description);\n        this.children[key] = suite;\n      }\n      return suite;\n    };\n\n    /*\n     * Adds specs to this suite.\n     *\n     * The specs will either consist of a standard Jasmine specs function (if\n     * the caller sets suite.specs), or a set of internally-generated describe()\n     * calls.\n     */\n    SuiteInfo.prototype._addSpecs = function () {\n      var key;\n      if (!this.specs) {\n        for (key in this.children) {\n          if (this.children.hasOwnProperty(key)) {\n            this.children[key].describe(this);\n          }\n        }\n      } else if (!this._added) {\n        this.specs.call(this._suiteObj);\n      }\n    };\n\n    /*\n     * Runs a describe() for the suite.\n     *\n     * This will run through the tree of specs/suites and generate the set of\n     * nested describe() calls. Each of these will be registered with Jasmine.\n     *\n     * The result will be a jasmine.Suite object.\n     */\n    SuiteInfo.prototype.describe = function (parentSuiteInfo) {\n      var self = this;\n      if (self._added) {\n        self._addSpecs();\n      } else {\n        describe(self.description, function () {\n          var parentSuiteObj, oldParentSuiteObj, i;\n          self._suiteObj = _curSuiteObj;\n          console.assert(self._suiteObj);\n          if (parentSuiteInfo) {\n            parentSuiteObj = parentSuiteInfo._suiteObj;\n            oldParentSuiteObj = self._suiteObj.parentSuite;\n            if (oldParentSuiteObj !== parentSuiteObj) {\n              /*\n               * Remove the suite object from the old parent. This could\n               * potentially be slow, but in reality it's not going to\n               * have a large search space for most suites.\n               */\n              i = oldParentSuiteObj.children.indexOf(self._suiteObj);\n              if (i !== -1) {\n                oldParentSuiteObj.children.splice(i, 1);\n              }\n\n              /* Add the suite to the new parent and fix relations. */\n              parentSuiteObj.addChild(self._suiteObj);\n              self._suiteObj.parentSuite = parentSuiteObj;\n\n              /* Re-generate the full name of the suite. */\n              self._suiteObj.result.fullName = self._suiteObj.getFullName();\n            }\n          }\n          self._addSpecs();\n          self._added = true;\n        });\n      }\n      return self._suiteObj;\n    };\n    _rootSuite = new SuiteInfo();\n\n    /*\n     * We need access to the suite objects, which we can no longer get with 'this'\n     * above. So we need to monkey-patch the SuiteBuilder to capture this.\n     */\n    const suiteBuilderProto = jasmine.SuiteBuilder.prototype;\n    const _addSpecsToSuite = suiteBuilderProto.addSpecsToSuite_;\n    suiteBuilderProto.addSpecsToSuite_ = function (suite, definitionFn) {\n      _curSuiteObj = suite;\n      return _addSpecsToSuite.call(this, suite, definitionFn);\n    };\n\n    /*\n     * Defines a test suite with a nested, reusable namespace.\n     *\n     * The namespace consists of a '/'-separated list of names that the provided\n     * specs of tests belong to. Each name in the list is equivalent to a\n     * Jasmine describe() call, nested in the spec for the previous name, with\n     * the exception these names can be reused across files.\n     *\n     * If more than one file has the same prefix for its namespace, those\n     * describe() suites will be reused. This makes it really easy to categorize\n     * tests under file paths, project names, or anything else, allowing those\n     * related tests to be run together.\n     */\n    function suite(namespace, specs) {\n      var parts = namespace.split('/'),\n        parentSuite = _rootSuite,\n        key = '',\n        description,\n        curSuite,\n        firstSuite,\n        i;\n      for (i = 0; i < parts.length; i++) {\n        description = parts[i];\n        key += '/' + description;\n        curSuite = parentSuite.getOrCreate(key, description);\n        parentSuite = curSuite;\n        if (!firstSuite) {\n          firstSuite = curSuite;\n        }\n      }\n\n      /* The last suite is the one that'll run the provided test specs. */\n      curSuite.specs = specs;\n      return firstSuite.describe();\n    }\n    jasmine.getGlobal().suite = suite;\n\n    exports.suite = suite;\n\n}));\n//# sourceMappingURL=index.js.map\n","import { suite } from '@beanbag/jasmine-suites';\n\n\n/* Export what's needed to the global namespace. */\nconst _global = typeof globalThis !== 'undefined' ? globalThis : self;\n\n_global.suite = suite;\n"],"names":["console","_suiteObj","SuiteInfo","suite","children","_addSpecs","describe","key","_added","specs","call","parentSuiteObj","self","assert","parentSuiteInfo","oldParentSuiteObj","parentSuite","i","addChild","_rootSuite","suiteBuilderProto","_curSuiteObj","curSuite","firstSuite","namespace","_global","globalThis"],"mappings":"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"}