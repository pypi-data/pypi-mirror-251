# This is a partial patch that applies after we have renamed `black` to `pyink`.
# This file is provided so it's easier to see the actual differences between Black and Pyink.
--- a/__init__.py
+++ b/__init__.py
@@ -67,7 +67,7 @@ from pyink.linegen import LN, LineGenera
 from pyink.lines import EmptyLineTracker, LinesBlock
 from pyink.mode import FUTURE_FLAG_TO_FEATURE, VERSION_TO_FEATURES, Feature
 from pyink.mode import Mode as Mode  # re-exported
-from pyink.mode import TargetVersion, supports_feature
+from pyink.mode import QuoteStyle, TargetVersion, supports_feature
 from pyink.nodes import (
     STARS,
     is_number_token,
@@ -78,6 +78,7 @@ from pyink.nodes import (
 from pyink.output import color_diff, diff, dump_to_file, err, ipynb_diff, out
 from pyink.parsing import InvalidInput  # noqa F401
 from pyink.parsing import lib2to3_parse, parse_ast, stringify_ast
+from pyink import ink
 from pyink.ranges import adjusted_lines, convert_unchanged_lines, parse_line_ranges
 from pyink.report import Changed, NothingChanged, Report
 from pyink.trans import iter_fexpr_spans
@@ -301,6 +302,38 @@ def validate_regex(
     ),
 )
 @click.option(
+    "--pyink/--no-pyink",
+    is_flag=True,
+    default=True,
+    help=(
+        "Enable the Pyink formatting mode. Disabling it should behave the same as"
+        " Black."
+    ),
+)
+@click.option(
+    "--pyink-indentation",
+    type=click.Choice(["2", "4"]),
+    default="4",
+    show_default=True,
+    help="The number of spaces used for indentation.",
+)
+@click.option(
+    "--pyink-lines",
+    multiple=True,
+    metavar="START-END",
+    help="Deprecated and replaced by --line-ranges",
+    default=(),
+)
+@click.option(
+    "--pyink-use-majority-quotes",
+    is_flag=True,
+    help=(
+        "When normalizing string quotes, infer preferred quote style by calculating the"
+        " majority in the file. Multi-line strings and docstrings are excluded from"
+        " this as they always use double quotes."
+    ),
+)
+@click.option(
     "--check",
     is_flag=True,
     help=(
@@ -492,6 +525,10 @@ def main(  # noqa: C901
     skip_magic_trailing_comma: bool,
     experimental_string_processing: bool,
     preview: bool,
+    pyink: bool,
+    pyink_indentation: str,
+    pyink_lines: Sequence[str],
+    pyink_use_majority_quotes: bool,
     quiet: bool,
     verbose: bool,
     required_version: Optional[str],
@@ -570,6 +607,7 @@ def main(  # noqa: C901
     else:
         # We'll autodetect later.
         versions = set()
+    pyink_indentation = 2 if pyink_indentation == "2" else 4
     mode = Mode(
         target_versions=versions,
         line_length=line_length,
@@ -581,6 +619,11 @@ def main(  # noqa: C901
         experimental_string_processing=experimental_string_processing,
         preview=preview,
         python_cell_magics=set(python_cell_magics),
+        is_pyink=pyink,
+        pyink_indentation=pyink_indentation,
+        quote_style=(
+            QuoteStyle.MAJORITY if pyink_use_majority_quotes else QuoteStyle.DOUBLE
+        ),
     )
 
     lines: List[Tuple[int, int]] = []
@@ -595,6 +638,18 @@ def main(  # noqa: C901
             err(str(e))
             ctx.exit(1)
 
+    if pyink_lines:
+        out(
+            "WARNING: --pyink-lines= is deprecated and replaced by --line-ranges=.",
+            fg="yellow",
+        )
+        if not lines:
+            try:
+                lines = parse_line_ranges(pyink_lines)
+            except ValueError as e:
+                err(str(e))
+                ctx.exit(1)
+
     if code is not None:
         # Run in quiet mode by default with -c; the extra output isn't useful.
         # You can still pass -v to get verbose output.
@@ -1192,6 +1247,8 @@ def _format_str_once(
         future_imports = get_future_imports(src_node)
         versions = detect_target_versions(src_node, future_imports=future_imports)
 
+    if mode.string_normalization and mode.quote_style == QuoteStyle.MAJORITY:
+        mode = replace(mode, majority_quote=ink.majority_quote(src_node))
     context_manager_features = {
         feature
         for feature in {Feature.PARENTHESIZED_CONTEXT_MANAGERS}
--- a/_width_table.py
+++ b/_width_table.py
@@ -3,7 +3,7 @@
 # Unicode 15.0.0
 from typing import Final, List, Tuple
 
-WIDTH_TABLE: Final[List[Tuple[int, int, int]]] = [
+WIDTH_TABLE: Final[Tuple[Tuple[int, int, int], ...]] = (
     (0, 0, 0),
     (1, 31, -1),
     (127, 159, -1),
@@ -475,4 +475,4 @@ WIDTH_TABLE: Final[List[Tuple[int, int,
     (131072, 196605, 2),
     (196608, 262141, 2),
     (917760, 917999, 0),
-]
+)
--- a/linegen.py
+++ b/linegen.py
@@ -9,6 +9,11 @@ from enum import Enum, auto
 from functools import partial, wraps
 from typing import Collection, Iterator, List, Optional, Set, Union, cast
 
+if sys.version_info < (3, 8):
+    from typing_extensions import Final, Literal
+else:
+    from typing import Final, Literal
+
 from pyink.brackets import (
     COMMA_PRIORITY,
     DOT_PRIORITY,
@@ -17,6 +22,7 @@ from pyink.brackets import (
 )
 from pyink.comments import FMT_OFF, generate_comments, list_comments
 from pyink.lines import (
+    Indentation,
     Line,
     RHSResult,
     append_leaves,
@@ -86,6 +92,15 @@ LeafID = int
 LN = Union[Leaf, Node]
 
 
+# Use a single-value enum as a sentinel object so that we could use it
+# inside a `Literal[]`.
+class _Dedent(Enum):
+    _DEDENT = auto()
+
+
+_DEDENT = _Dedent._DEDENT
+
+
 class CannotSplit(CannotTransform):
     """A readable split that fits the allotted line length is impossible."""
 
@@ -105,7 +120,9 @@ class LineGenerator(Visitor[Line]):
         self.current_line: Line
         self.__post_init__()
 
-    def line(self, indent: int = 0) -> Iterator[Line]:
+    def line(
+        self, indent: Union[Indentation, Literal[_Dedent._DEDENT], None] = None
+    ) -> Iterator[Line]:
         """Generate a line.
 
         If the line is empty, only emit if it makes sense.
@@ -114,7 +131,10 @@ class LineGenerator(Visitor[Line]):
         If any lines were generated, set up a new current_line.
         """
         if not self.current_line:
-            self.current_line.depth += indent
+            if indent is _DEDENT:
+                self.current_line.depth = self.current_line.depth[:-1]
+            elif indent is not None:
+                self.current_line.depth = self.current_line.depth + (indent,)
             return  # Line is empty, don't emit. Creating a new one unnecessary.
 
         if (
@@ -129,7 +149,13 @@ class LineGenerator(Visitor[Line]):
             return
 
         complete_line = self.current_line
-        self.current_line = Line(mode=self.mode, depth=complete_line.depth + indent)
+        if indent is _DEDENT:
+            depth = complete_line.depth[:-1]
+        elif indent is not None:
+            depth = complete_line.depth + (indent,)
+        else:
+            depth = complete_line.depth
+        self.current_line = Line(mode=self.mode, depth=depth)
         yield complete_line
 
     def visit_default(self, node: LN) -> Iterator[Line]:
@@ -156,7 +182,9 @@ class LineGenerator(Visitor[Line]):
                 node.prefix = ""
             if self.mode.string_normalization and node.type == token.STRING:
                 node.value = normalize_string_prefix(node.value)
-                node.value = normalize_string_quotes(node.value)
+                node.value = normalize_string_quotes(
+                    node.value, preferred_quote=self.mode.preferred_quote
+                )
             if node.type == token.NUMBER:
                 normalize_numeric_literal(node)
             if node.type not in WHITESPACE:
@@ -166,7 +194,10 @@ class LineGenerator(Visitor[Line]):
     def visit_test(self, node: Node) -> Iterator[Line]:
         """Visit an `x if y else z` test"""
 
-        if Preview.parenthesize_conditional_expressions in self.mode:
+        if (
+            Preview.parenthesize_conditional_expressions in self.mode
+            and not self.mode.is_pyink
+        ):
             already_parenthesized = (
                 node.prev_sibling and node.prev_sibling.type == token.LPAR
             )
@@ -182,7 +213,7 @@ class LineGenerator(Visitor[Line]):
     def visit_INDENT(self, node: Leaf) -> Iterator[Line]:
         """Increase indentation level, maybe yield a line."""
         # In blib2to3 INDENT never holds comments.
-        yield from self.line(+1)
+        yield from self.line(Indentation.SCOPE)
         yield from self.visit_default(node)
 
     def visit_DEDENT(self, node: Leaf) -> Iterator[Line]:
@@ -197,7 +228,7 @@ class LineGenerator(Visitor[Line]):
         yield from self.visit_default(node)
 
         # Finally, emit the dedent.
-        yield from self.line(-1)
+        yield from self.line(_DEDENT)
 
     def visit_stmt(
         self, node: Node, keywords: Set[str], parens: Set[str]
@@ -310,9 +341,9 @@ class LineGenerator(Visitor[Line]):
             if condition and is_stub_body(node):
                 yield from self.visit_default(node)
             else:
-                yield from self.line(+1)
+                yield from self.line(Indentation.SCOPE)
                 yield from self.visit_default(node)
-                yield from self.line(-1)
+                yield from self.line(_DEDENT)
 
         else:
             if (
@@ -423,10 +454,15 @@ class LineGenerator(Visitor[Line]):
         yield from self.visit_default(node)
 
     def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:
-        if Preview.hex_codes_in_unicode_sequences in self.mode:
+        if (
+            Preview.hex_codes_in_unicode_sequences in self.mode
+            and not self.mode.is_pyink
+        ):
             normalize_unicode_escape_sequences(leaf)
 
-        if is_docstring(leaf) and not re.search(r"\\\s*\n", leaf.value):
+        if is_docstring(leaf, self.mode.is_pyink) and not re.search(
+            r"\\\s*\n", leaf.value
+        ):
             # We're ignoring docstrings with backslash newline escapes because changing
             # indentation of those changes the AST representation of the code.
             if self.mode.string_normalization:
@@ -437,7 +473,9 @@ class LineGenerator(Visitor[Line]):
                 # formatting as visit_default() is called *after*. To avoid a
                 # situation where this function formats a docstring differently on
                 # the second pass, normalize it early.
-                docstring = normalize_string_quotes(docstring)
+                docstring = normalize_string_quotes(
+                    docstring, preferred_quote=self.mode.preferred_quote
+                )
             else:
                 docstring = leaf.value
             prefix = get_string_prefix(docstring)
@@ -451,8 +489,9 @@ class LineGenerator(Visitor[Line]):
             quote_len = 1 if docstring[1] != quote_char else 3
             docstring = docstring[quote_len:-quote_len]
             docstring_started_empty = not docstring
-            indent = " " * 4 * self.current_line.depth
+            indent = " " * self.current_line.indentation_spaces()
 
+            original_has_trailing_newline = docstring.endswith("\n")
             if is_multiline_string(leaf):
                 docstring = fix_docstring(docstring, indent)
             else:
@@ -493,7 +532,13 @@ class LineGenerator(Visitor[Line]):
                 # If docstring is one line, we don't put the closing quotes on a
                 # separate line because it looks ugly (#3320).
                 lines = docstring.splitlines()
-                last_line_length = len(lines[-1]) if docstring else 0
+                last_line_length = (
+                    # When docstring ends with '\n' the last line is empty,
+                    # not the last item from splitlines().
+                    len(lines[-1])
+                    if docstring and not docstring.endswith("\n")
+                    else 0
+                )
 
                 # If adding closing quotes would cause the last line to exceed
                 # the maximum line length then put a line break before the
@@ -505,6 +550,15 @@ class LineGenerator(Visitor[Line]):
                     and not has_trailing_backslash
                 ):
                     leaf.value = prefix + quote + docstring + "\n" + indent + quote
+                elif (
+                    not indent
+                    and len(lines) > 1
+                    and not docstring.endswith("\n")
+                    and original_has_trailing_newline
+                ):
+                    # Special case for module docstrings that put trailing quotes on
+                    # their own line.
+                    leaf.value = prefix + quote + docstring + "\n" + indent + quote
                 else:
                     leaf.value = prefix + quote + docstring + quote
             else:
@@ -539,7 +593,8 @@ class LineGenerator(Visitor[Line]):
         self.visit_expr_stmt = partial(v, keywords=Ø, parens=assignments)
 
         self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
-        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
+        if not self.mode.is_pyink:
+            self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
         self.visit_del_stmt = partial(v, keywords=Ø, parens={"del"})
         self.visit_async_funcdef = self.visit_async_stmt
         self.visit_decorated = self.visit_decorators
@@ -585,10 +640,19 @@ def transform_line(
 
     ll = mode.line_length
     sn = mode.string_normalization
-    string_merge = StringMerger(ll, sn)
-    string_paren_strip = StringParenStripper(ll, sn)
-    string_split = StringSplitter(ll, sn)
-    string_paren_wrap = StringParenWrapper(ll, sn)
+    preferred_quote = mode.preferred_quote
+    string_merge = StringMerger(
+        ll, sn, preferred_quote=preferred_quote, line_str=line_str
+    )
+    string_paren_strip = StringParenStripper(
+        ll, sn, preferred_quote=preferred_quote, line_str=line_str
+    )
+    string_split = StringSplitter(
+        ll, sn, preferred_quote=preferred_quote, line_str=line_str
+    )
+    string_paren_wrap = StringParenWrapper(
+        ll, sn, preferred_quote=preferred_quote, line_str=line_str
+    )
 
     transformers: List[Transformer]
     if (
@@ -798,7 +862,6 @@ def _first_right_hand_split(
     omit: Collection[LeafID] = (),
 ) -> RHSResult:
     """Split the line into head, body, tail starting with the last bracket pair.
-
     Note: this function should not have side effects. It's relied upon by
     _maybe_split_omitting_optional_parens to get an opinion whether to prefer
     splitting on the right side of an assignment statement.
@@ -1069,7 +1132,7 @@ def bracket_split_build_line(
     result = Line(mode=original.mode, depth=original.depth)
     if component is _BracketSplitComponent.body:
         result.inside_brackets = True
-        result.depth += 1
+        result.depth = result.depth + (Indentation.CONTINUATION,)
         if leaves:
             # Ensure a trailing comma for imports and standalone function arguments, but
             # be careful not to add one after any comments or within type annotations.
@@ -1098,6 +1161,13 @@ def bracket_split_build_line(
                     and leaves[0].parent.next_sibling
                     and leaves[0].parent.next_sibling.type == token.VBAR
                 )
+                # Except the false negatives above for PEP 604 unions where we
+                # can't add the comma.
+                and not (
+                    leaves[0].parent
+                    and leaves[0].parent.next_sibling
+                    and leaves[0].parent.next_sibling.type == token.VBAR
+                )
             )
 
             if original.is_import or no_commas:
@@ -1640,7 +1710,7 @@ def generate_trailers_to_omit(line: Line
     if not line.magic_trailing_comma:
         yield omit
 
-    length = 4 * line.depth
+    length = line.indentation_spaces()
     opening_bracket: Optional[Leaf] = None
     closing_bracket: Optional[Leaf] = None
     inner_brackets: Set[LeafID] = set()
--- a/lines.py
+++ b/lines.py
@@ -1,5 +1,7 @@
+from enum import Enum, auto
 import itertools
 import math
+import re
 from dataclasses import dataclass, field
 from typing import (
     Callable,
@@ -46,13 +48,28 @@ Index = int
 LeafID = int
 LN = Union[Leaf, Node]
 
+# This regex should contain a single capture group capturing the entire match.
+_PRAGMA_REGEX = re.compile("( *# (?:pylint|pytype):)")
+
+
+class Indentation(Enum):
+    SCOPE = auto()  # Scope indentation.
+    CONTINUATION = auto()  # Continuation/hanging indentation.
+
+    def num_spaces(self, mode: Mode) -> int:
+        if mode.is_pyink and self == Indentation.SCOPE:
+            return mode.pyink_indentation
+        else:
+            # Both pyink and black use 4 spaces for continuations.
+            return 4
+
 
 @dataclass
 class Line:
     """Holds leaves and comments. Can be printed with `str(line)`."""
 
     mode: Mode = field(repr=False)
-    depth: int = 0
+    depth: Tuple[Indentation, ...] = field(default_factory=tuple)
     leaves: List[Leaf] = field(default_factory=list)
     # keys ordered like `leaves`
     comments: Dict[LeafID, List[Leaf]] = field(default_factory=dict)
@@ -61,6 +78,9 @@ class Line:
     should_split_rhs: bool = False
     magic_trailing_comma: Optional[Leaf] = None
 
+    def indentation_spaces(self) -> int:
+        return sum(d.num_spaces(self.mode) for d in self.depth)
+
     def append(
         self, leaf: Leaf, preformatted: bool = False, track_bracket: bool = False
     ) -> None:
@@ -104,7 +124,7 @@ class Line:
         or when a standalone comment is not the first leaf on the line.
         """
         if (
-            self.bracket_tracker.depth == 0
+            not self.bracket_tracker.depth
             or self.bracket_tracker.any_open_for_or_lambda()
         ):
             if self.is_comment:
@@ -333,6 +353,29 @@ class Line:
 
         return False
 
+    def trailing_pragma_comment_length(self) -> int:
+        if not self.leaves:
+            return 0
+
+        trailing_comments = self.comments.get(id(self.leaves[-1]), [])
+        if (
+            not trailing_comments
+            and len(self.leaves) > 1
+            and self.leaves[-1].type == token.RPAR
+            and not self.leaves[-1].value
+        ):
+            # When last leaf is an invisible paren, the trailing comment is
+            # attached to the leaf before.
+            trailing_comments = self.comments.get(id(self.leaves[-2]), [])
+        length = 0
+        for comment in trailing_comments:
+            # str(comment) contains the whitespace preceding the `#`
+            comment_str = str(comment)
+            parts = _PRAGMA_REGEX.split(comment_str, maxsplit=1)
+            if len(parts) == 3:
+                length += len(parts[1]) + len(parts[2])
+        return length
+
     def contains_multiline_strings(self) -> bool:
         return any(is_multiline_string(leaf) for leaf in self.leaves)
 
@@ -485,7 +528,7 @@ class Line:
         if not self:
             return "\n"
 
-        indent = "    " * self.depth
+        indent = " " * self.indentation_spaces()
         leaves = iter(self.leaves)
         first = next(leaves)
         res = f"{first.prefix}{indent}{first.value}"
@@ -558,7 +601,7 @@ class EmptyLineTracker:
         """
         form_feed = (
             Preview.allow_form_feeds in self.mode
-            and current_line.depth == 0
+            and not current_line.depth
             and bool(current_line.leaves)
             and "\f\n" in current_line.leaves[0].prefix
         )
@@ -609,7 +652,7 @@ class EmptyLineTracker:
 
     def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
         max_allowed = 1
-        if current_line.depth == 0:
+        if not current_line.depth:
             max_allowed = 1 if self.mode.is_pyi else 2
         if current_line.leaves:
             # Consume the first leaf's extra newlines.
@@ -624,7 +667,7 @@ class EmptyLineTracker:
         depth = current_line.depth
 
         previous_def = None
-        while self.previous_defs and self.previous_defs[-1].depth >= depth:
+        while self.previous_defs and len(self.previous_defs[-1].depth) >= len(depth):
             previous_def = self.previous_defs.pop()
 
         if previous_def is not None:
@@ -673,10 +716,25 @@ class EmptyLineTracker:
 
         if (
             self.previous_line
-            and self.previous_line.is_import
+            and (
+                self.previous_line.is_import
+                or self.previous_line.is_fmt_pass_converted(
+                    first_leaf_matches=is_import
+                )
+            )
             and not current_line.is_import
+            and not (
+                # Should not add empty lines before a STANDALONE_COMMENT.
+                current_line.is_comment
+                and not current_line.is_fmt_pass_converted()
+            )
+            and not (
+                # Should not add empty lines between fmt pass lines.
+                current_line.is_fmt_pass_converted()
+                and self.previous_line.is_fmt_pass_converted()
+            )
             and not current_line.is_fmt_pass_converted(first_leaf_matches=is_import)
-            and depth == self.previous_line.depth
+            and len(depth) == len(self.previous_line.depth)
         ):
             return (before or 1), 0
 
@@ -689,12 +747,20 @@ class EmptyLineTracker:
                 return 0, 1
             return before, 1
 
+        if (
+            self.mode.is_pyink
+            and self.previous_line
+            and self.previous_line.is_class
+            and current_line.is_comment
+        ):
+            return before, 0
+
         # In preview mode, always allow blank lines, except right before a function
         # docstring
         is_empty_first_line_ok = (
             Preview.allow_empty_first_line_in_block in current_line.mode
             and (
-                not is_docstring(current_line.leaves[0])
+                not is_docstring(current_line.leaves[0], is_pyink=self.mode.is_pyink)
                 or (
                     self.previous_line
                     and self.previous_line.leaves[0]
@@ -728,15 +794,16 @@ class EmptyLineTracker:
 
             return 0, 0
 
-        if self.previous_line.depth < current_line.depth and (
-            self.previous_line.is_class or self.previous_line.is_def
+        if len(self.previous_line.depth) < len(current_line.depth) and (
+            (not self.mode.is_pyink and self.previous_line.is_class)
+            or self.previous_line.is_def
         ):
             return 0, 0
 
         comment_to_add_newlines: Optional[LinesBlock] = None
         if (
             self.previous_line.is_comment
-            and self.previous_line.depth == current_line.depth
+            and len(self.previous_line.depth) == len(current_line.depth)
             and before == 0
         ):
             slc = self.semantic_leading_comment
@@ -753,9 +820,9 @@ class EmptyLineTracker:
 
         if self.mode.is_pyi:
             if current_line.is_class or self.previous_line.is_class:
-                if self.previous_line.depth < current_line.depth:
+                if len(self.previous_line.depth) < len(current_line.depth):
                     newlines = 0
-                elif self.previous_line.depth > current_line.depth:
+                elif len(self.previous_line.depth) > len(current_line.depth):
                     newlines = 1
                 elif current_line.is_stub_class and self.previous_line.is_stub_class:
                     # No blank line between classes with an empty body
@@ -784,7 +851,7 @@ class EmptyLineTracker:
                     # Blank line between a block of functions (maybe with preceding
                     # decorators) and a block of non-functions
                     newlines = 1
-            elif self.previous_line.depth > current_line.depth:
+            elif len(self.previous_line.depth) > len(current_line.depth):
                 newlines = 1
             else:
                 newlines = 0
@@ -852,10 +919,14 @@ def is_line_short_enough(  # noqa: C901
         line_str = line_to_string(line)
 
     width = str_width if Preview.respect_east_asian_width in mode else len
+    if line.mode.is_pyink:
+        effective_length = width(line_str) - line.trailing_pragma_comment_length()
+    else:
+        effective_length = width(line_str)
 
     if Preview.multiline_string_handling not in mode:
         return (
-            width(line_str) <= mode.line_length
+            effective_length <= mode.line_length
             and "\n" not in line_str  # multiline strings
             and not line.contains_standalone_comments()
         )
@@ -864,7 +935,7 @@ def is_line_short_enough(  # noqa: C901
         return False
     if "\n" not in line_str:
         # No multiline strings (MLS) present
-        return width(line_str) <= mode.line_length
+        return effective_length <= mode.line_length
 
     first, *_, last = line_str.split("\n")
     if width(first) > mode.line_length or width(last) > mode.line_length:
@@ -1071,7 +1142,7 @@ def can_omit_invisible_parens(
 def _can_omit_opening_paren(line: Line, *, first: Leaf, line_length: int) -> bool:
     """See `can_omit_invisible_parens`."""
     remainder = False
-    length = 4 * line.depth
+    length = line.indentation_spaces()
     _index = -1
     for _index, leaf, leaf_length in line.enumerate_with_length():
         if leaf.type in CLOSING_BRACKETS and leaf.opening_bracket is first:
@@ -1095,7 +1166,7 @@ def _can_omit_opening_paren(line: Line,
 
 def _can_omit_closing_paren(line: Line, *, last: Leaf, line_length: int) -> bool:
     """See `can_omit_invisible_parens`."""
-    length = 4 * line.depth
+    length = line.indentation_spaces()
     seen_other_brackets = False
     for _index, leaf, leaf_length in line.enumerate_with_length():
         length += leaf_length
--- a/mode.py
+++ b/mode.py
@@ -8,7 +8,7 @@ from dataclasses import dataclass, field
 from enum import Enum, auto
 from hashlib import sha256
 from operator import attrgetter
-from typing import Dict, Final, Set
+from typing import Dict, Final, Literal, Set
 from warnings import warn
 
 from pyink.const import DEFAULT_LINE_LENGTH
@@ -202,11 +202,33 @@ class Deprecated(UserWarning):
     """Visible deprecation warning."""
 
 
+class Quote(Enum):
+    SINGLE = "'"
+    DOUBLE = '"'
+
+    def cache_key(self) -> str:
+        # On Windows, paths can't contain a double quote.
+        if self == Quote.SINGLE:
+            return "0"
+        else:
+            return "1"
+
+
+class QuoteStyle(Enum):
+    SINGLE = auto()
+    DOUBLE = auto()
+    MAJORITY = auto()
+
+
 @dataclass
 class Mode:
     target_versions: Set[TargetVersion] = field(default_factory=set)
     line_length: int = DEFAULT_LINE_LENGTH
     string_normalization: bool = True
+    # No effect if string_normalization is False
+    quote_style: QuoteStyle = QuoteStyle.DOUBLE
+    # Overridden later when quote_style is MAJORITY
+    majority_quote: Quote = Quote.DOUBLE
     is_pyi: bool = False
     is_ipynb: bool = False
     skip_source_first_line: bool = False
@@ -214,6 +236,8 @@ class Mode:
     experimental_string_processing: bool = False
     python_cell_magics: Set[str] = field(default_factory=set)
     preview: bool = False
+    is_pyink: bool = False
+    pyink_indentation: Literal[2, 4] = 4
 
     def __post_init__(self) -> None:
         if self.experimental_string_processing:
@@ -232,6 +256,9 @@ class Mode:
         """
         if feature is Preview.string_processing:
             return self.preview or self.experimental_string_processing
+        # dummy_implementations is temporarily disabled in Pyink.
+        if feature is Preview.dummy_implementations and self.is_pyink:
+            return False
         return self.preview
 
     def get_cache_key(self) -> str:
@@ -246,12 +273,25 @@ class Mode:
             version_str,
             str(self.line_length),
             str(int(self.string_normalization)),
+            str(self.quote_style.value),
+            self.majority_quote.cache_key(),
             str(int(self.is_pyi)),
             str(int(self.is_ipynb)),
             str(int(self.skip_source_first_line)),
             str(int(self.magic_trailing_comma)),
             str(int(self.experimental_string_processing)),
             str(int(self.preview)),
+            str(int(self.is_pyink)),
+            str(self.pyink_indentation),
             sha256((",".join(sorted(self.python_cell_magics))).encode()).hexdigest(),
         ]
         return ".".join(parts)
+
+    @property
+    def preferred_quote(self) -> Quote:
+        if self.quote_style == QuoteStyle.MAJORITY:
+            return self.majority_quote
+        elif self.quote_style == QuoteStyle.SINGLE:
+            return Quote.SINGLE
+        else:
+            return Quote.DOUBLE
--- a/nodes.py
+++ b/nodes.py
@@ -530,7 +530,7 @@ def is_arith_like(node: LN) -> bool:
     }
 
 
-def is_docstring(leaf: Leaf) -> bool:
+def is_docstring(leaf: Leaf, is_pyink: bool) -> bool:
     if leaf.type != token.STRING:
         return False
 
@@ -549,6 +549,16 @@ def is_docstring(leaf: Leaf) -> bool:
         # grammar. We're safe to return True without further checks.
         return True
 
+    # Module docstring.
+    if (
+        is_pyink
+        and prev_siblings_are(leaf.parent, [None, syms.simple_stmt])
+        and leaf.parent
+        and leaf.parent.parent
+        and leaf.parent.parent.type == syms.file_input
+    ):
+        return True
+
     return False
 
 
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,50 +1,23 @@
-# Example configuration for Black.
-
-# NOTE: you have to use single-quoted strings in TOML for regular expressions.
-# It's the equivalent of r-strings in Python.  Multiline strings are treated as
-# verbose regular expressions by Black.  Use [ ] to denote a significant space
-# character.
-
-[tool.black]
+[tool.pyink]
+# Yes, we use the _Black_ style to format _Pyink_ code.
+pyink = false
 line-length = 88
 target-version = ['py38']
 include = '\.pyi?$'
-extend-exclude = '''
-/(
-  # The following are specific to Black, you probably don't want those.
-  tests/data
-  | profiling
-)/
-'''
-# We use preview style for formatting Black itself. If you
-# want stable formatting across releases, you should keep
-# this off.
+extend-exclude = 'tests/data'
 preview = true
 
-# Build system information and other project-specific configuration below.
-# NOTE: You don't need this in your own Black configuration.
-
 [build-system]
-requires = ["hatchling>=1.20.0", "hatch-vcs", "hatch-fancy-pypi-readme"]
+requires = ["hatchling>=1.20.0", "hatch-vcs"]
 build-backend = "hatchling.build"
 
 [project]
-name = "black"
-description = "The uncompromising code formatter."
+name = "pyink"
+description = "Pyink is a python formatter, forked from Black with slightly different behavior."
 license = { text = "MIT" }
 requires-python = ">=3.8"
-authors = [
-  { name = "Łukasz Langa", email = "lukasz@langa.pl" },
-]
-keywords = [
-  "automation",
-  "autopep8",
-  "formatter",
-  "gofmt",
-  "pyfmt",
-  "rustfmt",
-  "yapf",
-]
+readme = "README.md"
+authors = [{name = "The Pyink Maintainers", email = "pyink-maintainers@google.com"}]
 classifiers = [
   "Development Status :: 5 - Production/Stable",
   "Environment :: Console",
@@ -69,48 +42,34 @@ dependencies = [
   "platformdirs>=2",
   "tomli>=1.1.0; python_version < '3.11'",
   "typing_extensions>=4.0.1; python_version < '3.11'",
+  "black==23.12.1",
 ]
-dynamic = ["readme", "version"]
+dynamic = ["version"]
 
 [project.optional-dependencies]
 colorama = ["colorama>=0.4.3"]
 uvloop = ["uvloop>=0.15.2"]
-d = [
-  "aiohttp>=3.7.4; sys_platform != 'win32' or implementation_name != 'pypy'",
-  "aiohttp>=3.7.4, !=3.9.0; sys_platform == 'win32' and implementation_name == 'pypy'",
-]
 jupyter = [
   "ipython>=7.8.0",
   "tokenize-rt>=3.2.0",
 ]
 
 [project.scripts]
-black = "black:patched_main"
-blackd = "blackd:patched_main [d]"
+pyink = "pyink:patched_main"
 
 [project.urls]
-Changelog = "https://github.com/psf/black/blob/main/CHANGES.md"
-Homepage = "https://github.com/psf/black"
-
-[tool.hatch.metadata.hooks.fancy-pypi-readme]
-content-type = "text/markdown"
-fragments = [
-  { path = "README.md" },
-  { path = "CHANGES.md" },
-]
+Changelog = "https://github.com/google/pyink/blob/pyink/CHANGES.md"
+Homepage = "https://github.com/google/pyink"
 
 [tool.hatch.version]
 source = "vcs"
 
 [tool.hatch.build.hooks.vcs]
-version-file = "src/_black_version.py"
+version-file = "src/_pyink_version.py"
 template = '''
 version = "{version}"
 '''
 
-[tool.hatch.build.targets.sdist]
-exclude = ["/profiling"]
-
 [tool.hatch.build.targets.wheel]
 only-include = ["src"]
 sources = ["src"]
@@ -121,7 +80,6 @@ macos-max-compat = true
 # Option below requires `tests/optional.py`
 addopts = "--strict-config --strict-markers"
 optional-tests = [
-  "no_blackd: run when `d` extra NOT installed",
   "no_jupyter: run when `jupyter` extra NOT installed",
 ]
 markers = [
@@ -145,36 +103,3 @@ filterwarnings = [
     # https://github.com/aio-libs/aiohttp/pull/7302
     "ignore:datetime.*utcfromtimestamp\\(\\) is deprecated and scheduled for removal:DeprecationWarning",
 ]
-[tool.coverage.report]
-omit = [
-  "src/blib2to3/*",
-  "tests/data/*",
-  "*/site-packages/*",
-  ".tox/*"
-]
-[tool.coverage.run]
-relative_files = true
-branch = true
-
-[tool.mypy]
-# Specify the target platform details in config, so your developers are
-# free to run mypy on Windows, Linux, or macOS and get consistent
-# results.
-python_version = "3.8"
-mypy_path = "src"
-strict = true
-# Unreachable blocks have been an issue when compiling mypyc, let's try to avoid 'em in the first place.
-warn_unreachable = true
-implicit_reexport = true
-show_error_codes = true
-show_column_numbers = true
-
-[[tool.mypy.overrides]]
-module = ["pathspec.*", "IPython.*", "colorama.*", "tokenize_rt.*", "uvloop.*", "_black_version.*"]
-ignore_missing_imports = true
-
-# CI only checks src/, but in case users are running LSP or similar we explicitly ignore
-# errors in test data files.
-[[tool.mypy.overrides]]
-module = ["tests.data.*"]
-ignore_errors = true
--- a/strings.py
+++ b/strings.py
@@ -8,6 +8,7 @@ from functools import lru_cache
 from typing import Final, List, Match, Pattern
 
 from pyink._width_table import WIDTH_TABLE
+from pyink.mode import Quote
 from blib2to3.pytree import Leaf
 
 STRING_PREFIX_CHARS: Final = "furbFURB"  # All possible string prefix characters.
@@ -170,8 +171,10 @@ def _cached_compile(pattern: str) -> Pat
     return re.compile(pattern)
 
 
-def normalize_string_quotes(s: str) -> str:
-    """Prefer double quotes but only if it doesn't cause more escaping.
+def normalize_string_quotes(s: str, *, preferred_quote: Quote) -> str:
+    """Prefer quotes by the `preferred_quote` parameter but only if it doesn't cause more escaping.
+
+    For three quotes strings, always use double-quote.
 
     Adds or removes backslashes as appropriate. Doesn't parse and fix
     strings nested in f-strings.
@@ -238,8 +241,8 @@ def normalize_string_quotes(s: str) -> s
     if new_escape_count > orig_escape_count:
         return s  # Do not introduce more escaping
 
-    if new_escape_count == orig_escape_count and orig_quote == '"':
-        return s  # Prefer double quotes
+    if new_escape_count == orig_escape_count and orig_quote == preferred_quote.value:
+        return s  # Prefer `preferred_quote`.
 
     return f"{prefix}{new_quote}{new_body}{new_quote}"
 
--- a/tests/empty.toml
+++ b/tests/empty.toml
@@ -1 +1,5 @@
 # Empty configuration file; used in tests to avoid interference from Black's own config.
+
+# Explicitly disable _Pyink_ mode so it's the same as the default _Black_ style.
+[tool.pyink]
+pyink = false
--- a/tests/test_black.py
+++ b/tests/test_black.py
@@ -2655,6 +2655,100 @@ class TestFileCollection:
             stdin_filename=stdin_filename,
         )
 
+    def decode_and_normalized(self, stdout: bytes) -> str:
+        # Make it easier to test on Windows. The test doesn't care about
+        # newlines.
+        return stdout.decode().replace("\r\n", "\n")
+
+    def test_pyink_default(self) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "example.py")
+        config = str(THIS_DIR / "empty.toml")
+        result = BlackRunner().invoke(
+            pyink.main, ["--diff", "--config", config, example]
+        )
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        assert "- pass\n+    pass\n" in self.decode_and_normalized(result.stdout_bytes)
+
+    def test_pyink_overrides(self) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "example.py")
+        config = str(path / "overrides.toml")
+        result = BlackRunner().invoke(
+            pyink.main, ["--diff", "--config", config, example]
+        )
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        assert "- pass\n+  pass\n" in self.decode_and_normalized(result.stdout_bytes)
+
+    def test_pyink_disable(self) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "example.py")
+        config = str(path / "disable.toml")
+        result = BlackRunner().invoke(
+            pyink.main, ["--diff", "--config", config, example]
+        )
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        stdout = self.decode_and_normalized(result.stdout_bytes)
+        assert (
+            """\
+-from very.long.package.path.my_org.my_very_long_project_name.awesome_backend.core_framework.util import my_long_module_name
++from very.long.package.path.my_org.my_very_long_project_name.awesome_backend.core_framework.util import (
++    my_long_module_name,
++)
+"""
+            in stdout
+        )
+        assert "- pass\n+    pass\n" in stdout
+
+    def test_pyink_in_tool_black(self) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "example.py")
+        config = str(path / "tool_black.toml")
+        result = BlackRunner().invoke(
+            pyink.main, ["--diff", "--config", config, example]
+        )
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        assert "- pass\n+    pass\n" in self.decode_and_normalized(result.stdout_bytes)
+
+    @pytest.mark.parametrize("values", [("7-7",), ("1-1", "7-7")])
+    def test_pyink_lines(self, values) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "example.py")
+        pyink_lines_args = []
+        for value in values:
+            pyink_lines_args.append(f"--pyink-lines={value}")
+        result = BlackRunner().invoke(
+            pyink.main, pyink_lines_args + ["--diff", example]
+        )
+        assert result.stdout_bytes is not None
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        stdout = self.decode_and_normalized(result.stdout_bytes)
+        assert "-from" not in stdout
+        assert "- pass\n+    pass\n" in stdout
+
+    def test_pyink_use_majority_quotes(self) -> None:
+        path = THIS_DIR / "data" / "pyink_configs"
+        example = str(path / "majority_quotes.py")
+        config = str(path / "majority_quotes.toml")
+        result = BlackRunner().invoke(
+            pyink.main, ["--diff", "--config", config, example]
+        )
+        assert result.exit_code == 0
+        assert result.stdout_bytes is not None
+
+        diff = """-_double = "Double"\n+_double = 'Double'\n"""
+        assert diff in self.decode_and_normalized(result.stdout_bytes)
+
     @patch("pyink.find_project_root", lambda *args: (THIS_DIR.resolve(), None))
     def test_get_sources_with_stdin_filename_and_force_exclude_and_symlink(
         self,
--- a/tests/util.py
+++ b/tests/util.py
@@ -262,6 +262,8 @@ def get_flags_parser() -> argparse.Argum
         ),
     )
     parser.add_argument("--line-ranges", action="append")
+    parser.add_argument("--pyink", default=False, action="store_true")
+    parser.add_argument("--pyink-indentation", default=4, type=int, choices=[2, 4])
     parser.add_argument(
         "--no-preview-line-length-1",
         default=False,
@@ -285,6 +287,8 @@ def parse_mode(flags_line: str) -> TestC
         is_ipynb=args.ipynb,
         magic_trailing_comma=not args.skip_magic_trailing_comma,
         preview=args.preview,
+        is_pyink=args.pyink,
+        pyink_indentation=args.pyink_indentation,
     )
     if args.line_ranges:
         lines = parse_line_ranges(args.line_ranges)
--- a/tox.ini
+++ b/tox.ini
@@ -95,4 +95,4 @@ setenv = PYTHONPATH = {toxinidir}/src
 skip_install = True
 commands =
     pip install -e .
-    black --check {toxinidir}/src {toxinidir}/tests
+    pyink --check {toxinidir}/src {toxinidir}/tests
--- a/trans.py
+++ b/trans.py
@@ -28,8 +28,8 @@ from typing import (
 from mypy_extensions import trait
 
 from pyink.comments import contains_pragma_comment
-from pyink.lines import Line, append_leaves
-from pyink.mode import Feature, Mode
+from pyink.lines import Indentation, Line, append_leaves
+from pyink.mode import Feature, Mode, Quote
 from pyink.nodes import (
     CLOSING_BRACKETS,
     OPENING_BRACKETS,
@@ -193,9 +193,18 @@ class StringTransformer(ABC):
 
     # Ideally this would be a dataclass, but unfortunately mypyc breaks when used with
     # `abc.ABC`.
-    def __init__(self, line_length: int, normalize_strings: bool) -> None:
+    def __init__(
+        self,
+        line_length: int,
+        normalize_strings: bool,
+        *,
+        preferred_quote: Quote,
+        line_str: str,
+    ) -> None:
         self.line_length = line_length
         self.normalize_strings = normalize_strings
+        self.preferred_quote = preferred_quote
+        self.line_str = line_str
 
     @abstractmethod
     def do_match(self, line: Line) -> TMatchResult:
@@ -673,7 +682,9 @@ class StringMerger(StringTransformer, Cu
 
         S_leaf = Leaf(token.STRING, S)
         if self.normalize_strings:
-            S_leaf.value = normalize_string_quotes(S_leaf.value)
+            S_leaf.value = normalize_string_quotes(
+                S_leaf.value, preferred_quote=self.preferred_quote
+            )
 
         # Fill the 'custom_splits' list with the appropriate CustomSplit objects.
         temp_string = S_leaf.value[len(prefix) + 1 : -1]
@@ -914,7 +925,13 @@ class StringParenStripper(StringTransfor
                     idx += 1
 
         if string_indices:
-            return Ok(string_indices)
+            if (
+                not line.mode.is_pyink
+                or len(self.line_str) - len(string_indices) * 2 <= self.line_length
+            ):
+                return Ok(string_indices)
+            else:
+                return TErr("With parens stripped, the line is still too long.")
         return TErr("This line has no strings wrapped in parens.")
 
     def do_transform(
@@ -1118,7 +1135,7 @@ class BaseStringSplitter(StringTransform
         #   NN: The leaf that is after N.
 
         # WMA4 the whitespace at the beginning of the line.
-        offset = line.depth * 4
+        offset = line.indentation_spaces()
 
         if is_valid_index(string_idx - 1):
             p_idx = string_idx - 1
@@ -1472,7 +1489,7 @@ class StringSplitter(BaseStringSplitter,
                 characters expand to two columns).
             """
             result = self.line_length
-            result -= line.depth * 4
+            result -= line.indentation_spaces()
             result -= 1 if ends_with_comma else 0
             result -= string_op_leaves_length
             return result
@@ -1483,11 +1500,11 @@ class StringSplitter(BaseStringSplitter,
         # The last index of a string of length N is N-1.
         max_break_width -= 1
         # Leading whitespace is not present in the string value (e.g. Leaf.value).
-        max_break_width -= line.depth * 4
+        max_break_width -= line.indentation_spaces()
         if max_break_width < 0:
             yield TErr(
                 f"Unable to split {LL[string_idx].value} at such high of a line depth:"
-                f" {line.depth}"
+                f" {line.indentation_spaces()}"
             )
             return
 
@@ -1784,7 +1801,9 @@ class StringSplitter(BaseStringSplitter,
 
     def _maybe_normalize_string_quotes(self, leaf: Leaf) -> None:
         if self.normalize_strings:
-            leaf.value = normalize_string_quotes(leaf.value)
+            leaf.value = normalize_string_quotes(
+                leaf.value, preferred_quote=self.preferred_quote
+            )
 
     def _normalize_f_string(self, string: str, prefix: str) -> str:
         """
@@ -1907,7 +1926,8 @@ class StringParenWrapper(BaseStringSplit
                 char == " " or char in SPLIT_SAFE_CHARS for char in string_value
             ):
                 # And will still violate the line length limit when split...
-                max_string_width = self.line_length - ((line.depth + 1) * 4)
+                # This is always a continuation indentation of 4 spaces.
+                max_string_width = self.line_length - (line.indentation_spaces() + 4)
                 if str_width(string_value) > max_string_width:
                     # And has no associated custom splits...
                     if not self.has_custom_splits(string_value):
@@ -2153,7 +2173,7 @@ class StringParenWrapper(BaseStringSplit
         string_value = LL[string_idx].value
         string_line = Line(
             mode=line.mode,
-            depth=line.depth + 1,
+            depth=line.depth + (Indentation.CONTINUATION,),
             inside_brackets=True,
             should_split_rhs=line.should_split_rhs,
             magic_trailing_comma=line.magic_trailing_comma,
