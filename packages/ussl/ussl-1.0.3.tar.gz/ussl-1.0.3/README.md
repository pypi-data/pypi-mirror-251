# USSL - USSC SOAR SCRIPT LIB

<!-- Оглавление -->
## Оглавление
- [1. Описание](#описание)
    - [Установка](#установка)
- [2. Взаимодействие с внешними системами](#взаимодействие-с-внешними-системами)
    - [Доступные методы модуля ussl.transport](#доступные-методы-модуля-ussltransport)
    - [Доступные на данный момент транспорты](#доступные-на-данный-момент-транспорты)
- [3. Взаимодействие с USSC SOAR](#взаимодействие-с-USSC-SOAR)
    - [Использование форматирования и переназначения](#использование-форматирования-и-переназначения)
    - [Ключи расширения](#ключи-расширения)
        - [__SOAR.input](#soarinput)
        - [__SOAR.secrets](#soarsecrets)
        - [__SOAR.format](#soarformat)
    - [Использование ussl.postprocessing в скриптах](#использование-usslpostprocessing-в-скриптах)
- [4. Что нового?](#что-нового)
- [5. TODO](#TODO)
<!-- /Оглавление -->

<!-- Описание -->
## Описание:

Библиотека разработана для упрощения работы с АРМ и сетевыми устройствами, а также для расширения возможностей USSC SOAR.

### Установка

#### Первый способ:
Установка через PyPI:
> `pip install ussl`

<br>

#### Второй способ:
Для установки из исходного кода необходимо склонировать репозиторий, установить setuptools:
> `pip install setuptools`

После чего установить пакет выполнив команду: 
> `python setup.py install`

<br>

#### Третий способ:
Для установки из .whl файла необходимо скачать его и выполнить команду (необходимо подключение к интернету):
> `pip install ussl-1.0-py2.py3-none-any.whl` 
____
<!-- /Описание -->


<!-- Взаимодействие с внешними системами -->
## Взаимодействие с внешними системами:
Для упрощения взаимодействия с различными системами в модуле ussl.transport реализован единый интерфейс. На вход он принимает объект Protocol, содержащий данные о подключении и объект (или список объектов) Query, содержащий данные о команде, которую необходимо выполнить; в качестве ответа возвращается объект Responce.
<br>
<details>
  <summary>Поля объекта Protocol</summary>

    Общие для всех интерфейсов поля:
        host: ip-адрес или имя хоста, к которому необходимо подключиться;
        username: имя пользователя, под которым необходимо подключиться;
        password: пароль от указанного пользователя;
        interface: интерфейс, к которому необходимо подключиться (ssh, winrm, и т.д.);
        port: порт, на котором работает интерфейс;
        query: команда или набор команд, которые необходимо выполнить;
        encoding: кодировка запроса;
        decoding: кодировка ответа;
        window_width: ширина окна консоли (влияет на форматирование ответа).

    Поля, специфичные для winrm:
        domain: имя домена к которому необходимо подключиться;
        scheme: схема подключения (http или https);
        path: путь до WS-Management;
        transport: протокол аутентификации.

    Поля, специфичные для ssh:
        clean_timeout: таймаут очищения канала;
        look_for_keys: включить или отключить аутентификацию по ключам;
        auth_timeout: таймаут авторизации;
        timeout: таймаут соединения;
        pem_file: значение закрытого ключа авторизации от указанного пользователя.

</details>
<details>
  <summary>Поля объекта Query</summary>

    command: содержит командe, которую необходимо выполнить;
    timeout: содержит время, отведенное на выпонение команды;
    expects: содержит регулярные выражения, которые описывают
    ожидаемый ответ от конечной системы;
    sudo: содержит пароль от супер пользователя или enable.

</details>
<details>
  <summary>Поля объекта Responce</summary>
  
    result: содержит исходный ответ от целевой системы;
    text: содержится форматированный ответ от целевой системы;
    status: содержится статус выполнения переданной команды.

</details>
<br>
Из особенностей поведения можно выделить следующее:

- При передаче списка Query в Responce попадёт вывод последней команды или, если в ходе выполнения произошла ошибка, вывод ошибки с соответствующим статусом;

- ...

### Доступные методы модуля ussl.transport:

 ```python
from ussl.transport import Transport
from ussl.model import Protocol, Query

Transport.connect(Protocol(...)) # Устанавливает соединение с указанными параметрами, ничего не возвращает. В этом случае Protocol может не содержать Query.
Transport.execute(..., query=[Query(...)]) # Выполняет команды (или команду) в случае, если было установлено соединение. 
Transport.connect_and_execute(Protocol(..., query=[Query(...)])) # Устанавливает подключение и выполняет команды (или команду).
 ```

### Доступные на данный момент транспорты:

* WinRM
* SSH
___
<!-- /Взаимодействие с внешними системами -->


<!-- Взаимодействие с USSC SOAR -->

## Взаимодействие с USSC SOAR:

Для упрощения взаимодействия с USSC SOAR были разработан модуль ussl.postprocessing. Он берёт на себя работу с вводом/выводом данных в скриптах, переназначение ключей объектов, а также форматирование значений объектов, передаваемых в скрипт стандратным образом.

### Использование форматирования и переназначения

Для того чтобы использовать возможности расширения, необходимо чтобы выполнялись следующие условия:

- На вход скрипта подается **объект** JSON (не массив);
- В объекте содержится как минимум один из [ключей расширения](#ключи-расширения);
- Полезная информация* передаётся в ключе *default_input*;

> \* под полезной информацией подразумевается объект json, который передаётся на вход плейбука, а также между его шагами.

Изначально использование расширений задумывалась через поле [Parameters](https://states-language.net/#filters).


### Ключи расширения

- #### __SOAR.input
    Ключ предназначен для замены ключей в default_input. Ключ должен содержать объект, ключи которого являются **заменяемыми** ключами, а значения **заменяющими**. В результате на вход скрипта придёт JSON с уже замененными ключами.

    <details>
    <summary>Пример использования</summary>

    ```json
    {
        "default_input": {
            "input": {
                "some_key": "some_value"
            }
        },
        "__SOAR.input": {
            "some_key": "new_some_key"
        }
    }
    ```
 
    > *При передаче через Parameters значения в поле default_input должно иметь следующий вид*.

    ```json
    {
        "default_input.$": ".$"
    }
    ```

    </details>

<br>

- #### __SOAR.secrets
    Ключ предназначен для замены ключей в secrets. Этот ключ может быть полезен при использовании одинаковых секретов на нескольких разных устройствах, без создания новых секретов. Логика работы аналогична [__SOAR.input](#soarinput).

    <details>
    <summary>Пример использования</summary>

    Объект secret невозможно сформировать из вне, поэтому, для примера, будет использоваться следующий объект:
    
    ```json
    {
        "secrets": {
            "passwd": "1234567890"
        }
    }
    ```
    
    Тогда замена будет выглядеть следующим образом.
    
    ```json
    {
        "default_input": {
            "input": {
                "some_key": "some_value"
            }
        },
        "__SOAR.secrets": {
            "passwd": "password"
        }
    }
    ```
    > *При передаче через Parameters значения в поле default_input должно иметь следующий вид*.

    ```json
    {
        "default_input.$": ".$"
    }
    ```

    </details>

<br>

- #### __SOAR.format
    Ключ предназначен для форматирования текста, без изменения кода скриптов. Ключ должен содержать объект, ключи которого являются новыми полями default_input (в случае, если такое поле уже существует, его значение будет заменено), а значение - строка, в которую можно подставлять значения переменных, существующих в объекте default_json. В случае, если такой переменной не найдено место подстановки останется без изменений. Для подстановки переменной необходимо использовать фигурные скобики.

    > *Ключ __SOAR.format применяется после выполнения скрипта, т.е. если до этого применялся ключ __SOAR.input, то нужно использовать уже **замененные** значения ключей*

    <details>
    <summary>Пример использования</summary>
    
    ```json
    {
        "default_input": {
            "input": {
                "some_key": "some_value"
            }
        },
        "__SOAR.format": {
            "new_key": "Строка, содержащая {some_key}"
        }
    }
    ```

    В результате выполнения преобразований, скрипт вернёт следующий JSON

    ```json
    {
        "some_key": "some_value",
        "new_key": "Строка, содержащая some_value"
    }
    ```

    > *При передаче через Parameters значения в поле default_input должно иметь следующий вид*.

    ```json
    {
        "default_input.$": ".$"
    }
    ```

    </details>

### Использование ussl.postprocessing в скриптах

Для того чтобы использовать возможности ussl.postprocessing достаточно при создании скрипта выполнить несколько условий, а именно:

- Создать класс с произвольным именем
- Унаследоваться от класса ussl.posprocessing.base.BaseFunction
- Реализовать метод *function*
- С помощью return вернуть **словарь**, с результатами выполнения команд/форматирования результатов
- В конце скрипта создать экземпляр созданного класса класса

```python
from ussl.postprocessing.base import BaseFunction


class NewFunction(BaseFunction):
    def function(self):
        ...
        result = {"reslut_key": "value"}

        return result


NewFunction()
```
___
<!-- /Взаимодействие с USSC SOAR -->

<!-- Основные изменения релиза -->
## Что нового?:

Добавлена версия 1.0

Необходимо протестировать на реальных скриптах, для выявленных ошибок просьба создавать [issue](https://gitlab.ussc.ru/ntolmachev/playbooks/-/issues).

___
<!-- Основные изменения релиза -->

<!-- Планы на будущее -->

## TODO:

* Добавить поддержку WMI
* Добавить поддержку LDAP (возможно с использованием ORM)
* Расширить возможности __SOAR.format
* Покрыть код библиотеки тестами
* ...

Предложения также можно оставлять в [issue](https://gitlab.ussc.ru/ntolmachev/playbooks/-/issues).

<!-- /Планы на будущее -->