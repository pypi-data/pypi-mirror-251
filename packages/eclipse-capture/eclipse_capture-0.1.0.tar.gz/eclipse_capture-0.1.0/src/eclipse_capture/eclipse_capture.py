import re
from datetime import datetime
from pytz import timezone
import numpy as np
import uuid

class EclipseCapture:

    def __init__(self):
        pass
    
class EclipseCaptureLine:
    def __init__(self, time, data):
        self.time = time
        self.data = data

    def generate_line(self) -> str:
        return "%f," % self.time + ",".join([str(x) for x in self.data])
    
    def parse_line(text: str):
        parts = text.split(",")
        # it = iter(parts)
        time = float(parts[0])

        data = []

        for i in range(1, len(parts)):
            if parts[i] == "":
                data.append(0)
                continue

            data.append(float(parts[i]))

        data = (np.array(data) - 512.0)/512.0
        return EclipseCaptureLine(time, data)

    
class EclipseCaptureFileInfo:

    METADATA_START = "## BEGIN METADATA ##"
    METADATA_END = "## END METADATA ##"
    PATTERN_METADATA_START = r"## BEGIN METADATA ##"
    PATTERN_METADATA_END = r"## END METADATA ##"
    PATTERN_METADATA = r"# ([A-Z_]+)\s+(.+)"
    PATTERN_FILENAME = r"(\d{8}_\d{6})-(\d{8}_\d{6})_(E[A-Z]\d{4})_([a-fA-F0-9]{8})"
    
    def __init__(self, start: datetime, 
                 end: datetime, 
                 capture_id: uuid.UUID,
                 node_id: str,
                 sample_rate: float):
        self.start = start
        self.end = end
        self.capture_id: uuid.UUID = capture_id
        self.node_id = node_id
        self.sample_rate = sample_rate
        pass

    def __repr__(self):
        return "EclipseCaptureFileInfo(%s, %s, %s, %s, %s)" % (self.start, self.end, self.capture_id, self.node_id, self.sample_rate)

    def validate(text: str):
        pass

    def filename(self) -> str:
        return "%s-%s_%s_%s.csv" % (self.start.strftime("%Y%m%d_%H%M%S"),
                                           self.end.strftime("%Y%m%d_%H%M%S"),
                                           self.node_id,
                                           self.capture_id.hex[:8])
    
    def parse_metadata(header_text: str):
        lines = header_text.splitlines()
        if not lines or len(lines) < 3:
            raise Exception("Invalid header")
        

        
        match = re.match(EclipseCaptureFileInfo.PATTERN_METADATA_START, lines.pop(0))
        if not match:
            raise Exception("Invalid header", lines[0])
        


        # Read each line
        metadata = {}

        while True:
            line = lines.pop(0)

            match = re.match(EclipseCaptureFileInfo.PATTERN_METADATA, line)
            
            if match:
                (key, value) = match.groups()
                metadata[key] = value
                continue

            if re.match(EclipseCaptureFileInfo.PATTERN_METADATA_END, line):
                break

            if match is None:
                raise Exception("Invalid header", line)

        if metadata["CAPTURE_ID"] is None:
            raise Exception("Missing CAPTURE_ID")
        
        if metadata["NODE_ID"] is None:
            raise Exception("Missing NODE_ID")

        if metadata["SAMPLE_RATE"] is None:
            raise Exception("Missing SAMPLE_RATE")
        
        if metadata["UTC_START"] is None:
            raise Exception("Missing UTC_START")
        
        if metadata["UTC_END"] is None:
            raise Exception("Missing UTC_END")
        
        start = datetime.fromtimestamp(float(metadata["UTC_START"]), tz=timezone("UTC"))
        end = datetime.fromtimestamp(float(metadata["UTC_END"]), tz=timezone("UTC"))
        capture_id = uuid.UUID(metadata["CAPTURE_ID"])
        node_id = metadata["NODE_ID"]
        sample_rate = float(metadata["SAMPLE_RATE"])

        return EclipseCaptureFileInfo(start, end, capture_id, node_id, sample_rate)

    def parse_filename(filename: str):
        match = re.match(EclipseCaptureFileInfo.PATTERN_FILENAME, filename)

        if not match:
            raise Exception("Invalid filename", filename)

        (start, end, node_id, capture_id) = match.groups()

        return (start, end, node_id, capture_id)

    def generate_header(self):
        header = EclipseCaptureFileInfo.METADATA_START + "\n"

        # Print mandatory fields
        header += "# FILE\t\t\t\t%s\n" % self.filename()
        header += "# CAPTURE_ID\t\t%s\n" % self.capture_id
        header += "# NODE_ID\t\t\t%s\n" % self.node_id
        header += "# SAMPLE_RATE\t\t%d\n" % self.sample_rate
        header += "# UTC_START\t\t\t%d\n" % self.start.timestamp()
        header += "# UTC_END\t\t\t%d\n" % self.end.timestamp()
        header += EclipseCaptureFileInfo.METADATA_END + "\n"

        header += "# This file was generated by eclipse-capture-python\n"
        header += "# https://github.com/Eclipse-Research-Group/eclipse-capture-python\n"

        return header

class EclipseCaptureFile:

    def __init__(self, file_path: str, info: EclipseCaptureFileInfo):
        self.file_path = file_path
        self.info = info
        self.lines = []
        pass

    def load(file_path: str):
        print("Loading file %s" % file_path)

        with open(file_path, 'r') as f:
            header_text = ""

            while True:
                line = f.readline()
                if not line:
                    break

                if line.startswith("#"):
                    header_text += line
                    continue
            
                break

            header = EclipseCaptureFileInfo.parse_metadata(header_text)
            file = EclipseCaptureFile(file_path, header)

        return file
    
    def load_all_lines(self):
        self.lines = []
        with open(self.file_path, 'r') as f:
            while True:
                line = f.readline()

                if not line:
                    break

                if line.startswith("#"):
                    continue

                self.lines.append(EclipseCaptureLine.parse_line(line))


class EclipseCaptureFileWriter:

    def __init__(self, file_path: str, info: EclipseCaptureFileInfo):
        self.file_path = file_path
        self.info = info
        self.lines = []
        pass