def giaie():
    print('''
Глеб и Анна исследуют эффективность лекарственного препарата АВС. Глеб, используя модель Анны, создал компьютерную программу, вычисляющую по заданным генетическим факторам вероятность (в процентах) успешного применения АВС. Программа Глеба накапливает полученные вероятности и в итоге выдает набор частот: n0,n1,...,n100 . Например, n75 – это число случаев, в которых программа Глеба получила вероятность 75%. Обработав 1000 образцов генетического материала, Анна нашла значения факторов и ввела их в программу. В результате был получен следующий набор частот: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0. Для завершения этапа исследования необходимо было подобрать распределение, соответствующее полученным частотам. Анна решила использовать распределение на отрезке [0,1] с плотностью f(x)=f(x;a,b)=abxa−1(1−xa)b−1 и целочисленными параметрами a,b в диапазоне от 1 до 20. В результате максимизации функции правдоподобия (при указанных ограничениях) Глебом были получены значения параметров: a^=A и b^=B . Задача: пусть X – случайная величина, распределения на отрезке [0,1] с плотностью f(x)=f(x;a^,b^) , F(x) – ее функция распределения. Требуется найти математическое ожидание E(X) и X0, 2=F−1(0,2) – квантиль уровня 0,2. Какой смысл для всей популяции имеют E(X) и X0, 2 ? В ответе укажите: 1) значение A ; 2) значение B ; 3) математическое ожидание E(X) ; 4) квантиль X0, 2 .

#pip install kumaraswamy

import scipy.stats as sts
import numpy as np
import scipy.optimize as opt
from kumaraswamy import kumaraswamy
import math

data2 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 1, 1, 3, 4, 4, 5, 4, 6, 6, 11, 9, 19, 23, 25, 33, 36, 36, 46, 46, 49, 58, 90, 76, 66, 69, 75, 68, 44, 39, 21, 16, 5, 2, 1, 0, 0, 0])

def kumaraswamy_logL(par, data):
    a, b = par
    logL = 0
    
    for x, freq in enumerate(data):
        eps = 1e-10
        x_prob = (x + 1) / len(data)  
        
        if x_prob < eps:
            x_prob = eps
        elif x_prob > 1 - eps:
            x_prob = 1 - eps

        logL += freq * (np.log(a * b) + (a - 1) * np.log(x_prob) + (b - 1) * np.log(1 - x_prob**a))

    return -logL

def kumaraswamy_MLE(data):
    res = opt.minimize(
        fun=lambda params, data: kumaraswamy_logL(params, data),
        x0=np.array([1, 1]),
        args=(data,),
        method='L-BFGS-B',
        bounds=[(1, 20), (1, 20)]
    )
    a, b = res.x
    return round(a), round(b)

A, B = kumaraswamy_MLE(data2)

Kum = kumaraswamy(A, B)
E = round(Kum.mean, 3)
X = round(Kum.ppf(0.2), 3)
print(f' A = {A}\n B = {B}\n E = {E}\n X = {X}')''')
    
          
def prsvi():
    print('''
Пусть (x1,y1);...;(x31,y31) – реализация случайной выборки (X1,Y1);...;(X31,Y31) из двумерного нормального распределения N(μx;μy;σ2x;σ2y;ρ) . Используя векторы x⃗ =(x1;...;x31) и y⃗ =(y1;...;y31) , постройте асимптотический 0,93- доверительный интервал (θˆ1;θˆ2) для коэффициента корреляции ρ . В ответе укажите: 1) выборочный коэффициент корреляции ρˆ; 2) верхнюю границу θˆ2 построенного доверительного интервала для ρ . Исходные данные: x⃗ = (-0,616; -0,238; 0,173; -0,255; 0,531; 0,718; -0,161; 0,371; -1,014; -0,413; -1,571; 0,485; 0,486; 0,688; -0,944; 0,155; 0,003; 0,111; 0,752; 0,783; -0,102; -0,74; -2,097; 1,349; -0,044; -0,617; -0,782; -0,873; -0,995; -1,256; -0,596), y⃗ = (-1,34; -0,25; 0,101; -0,626; -0,088; 0,539; -0,451; 0,233; -1,186; -0,423; -1,329; 0,231; 0,209; 0,638; -0,274; -0,491; -0,319; 0,294; 0,895; 1,164; -0,57; -1,078; -1,526; 1,491; 0,182; -0,31; -1,001; -0,969; -0,918; -0,904; -0,595).

x = '-0,616; -0,238; 0,173; -0,255; 0,531; 0,718; -0,161; 0,371; -1,014; -0,413; -1,571; 0,485; 0,486; 0,688; -0,944; 0,155; 0,003; 0,111; 0,752; 0,783; -0,102; -0,74; -2,097; 1,349; -0,044; -0,617; -0,782; -0,873; -0,995; -1,256; -0,596'
x = np.array(list(map(float, (x.replace(',', '.').replace(';', ',')).split(','))))

y = '-1,34; -0,25; 0,101; -0,626; -0,088; 0,539; -0,451; 0,233; -1,186; -0,423; -1,329; 0,231; 0,209; 0,638; -0,274; -0,491; -0,319; 0,294; 0,895; 1,164; -0,57; -1,078; -1,526; 1,491; 0,182; -0,31; -1,001; -0,969; -0,918; -0,904; -0,595'
y = np.array(list(map(float, (y.replace(',', '.').replace(';', ',')).split(','))))

import scipy.stats as sts
import numpy as np
import math

# 1st version

rhohat = np.corrcoef(x, y)[0][1]
n = len(x)
gamma = 0.93
alpha = 1 - gamma
z_al = sts.norm.isf(alpha/2)
z_n = math.atanh(rhohat)
theta_1 = math.tanh(z_n - 1/(np.sqrt(n - 3))*z_al)
theta_2 = math.tanh(z_n + 1/(np.sqrt(n - 3))*z_al)
print(f' Rho = {round(rhohat, 3)}\n Theta_2 = {round(theta_2, 3)}')


# 2nd version

import scipy.stats as sts
import numpy as np
import math

rho_ = np.corrcoef(x, y)[0][1]
n = len(x)
gamma = 0.93
z = sts.norm.ppf((1+gamma)/2)
delta = (1/((n-3)**0.5))*z
z_n = math.atanh(rho_)
theta_1 = math.tanh(math.atanh(rho_) - delta)
theta_2 = math.tanh(math.atanh(rho_) + delta)
print(f' Rho = {round(rhohat, 3)}\n Theta_2 = {round(theta_2, 3)}')
''')